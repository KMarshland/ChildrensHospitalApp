//--------------------------------------//             InfiniText////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;using System.IO;using System.Collections;using System.Collections.Generic;namespace InfiniText{		/// <summary>	/// A font face for a particular font family.	/// Note that you must consider if this font face has been loaded (see RequiresLoad) yet if you use deferred loading.	/// The metrics will always be available however - just the glyphs will not be if RequiresLoad is true.	/// </summary>		public class FontFace{				/// <summary>The font weight.</summary>		public int Weight;		/// <summary>The full name of this font face.</summary>		public string Name;		/// <summary>The winding order of glyphs of this font.</summary>		public bool Clockness;		/// <summary>Use this to disable the SDF extrusion of a font face which may cause the letters to go streaky in rare cases.</summary>		public bool DisableExtrude;		/// <summary>Is the clockness of this face known yet? If so, the first loaded glyph will figure it out.</summary>		public bool WindingUnknown=true;		/// <summary>Is this font face loaded at all? If it requires a load, call Load(). Note that metrics are available if it's not loaded.</summary>		public bool RequiresLoad=false;		/// <summary>The gap between vertical lines.</summary>		public float LineGap=0.1f;		/// <summary>The computed amount of units to "push" (sheer) the top of a glyph over by. Std default is 12 degrees; tan(12d) units.</summary>		public float ItalicAngle=0.213f;		/// <summary>The size of the ascender. Relative to em size.</summary>		public float Ascender;		/// <summary>The size of the descender. Relative to em size.</summary>		public float Descender;		/// <summary>The family that this font is in. Created by the first font in the family.</summary>		public FontFamily Family;		/// <summary>The number of characters in this font face.</summary>		public int CharacterCount;		/// <summary>The maximum advance width.</summary>		public float MaxAdvanceWidth;		/// <summary>The minimum left side bearing.</summary>		public float MinLeftSideBearing;		/// <summary>The minimum right side bearing.</summary>		public float MinRightSideBearing;		/// <summary>The maximum x extent.</summary>		public float MaxXExtent;		/// <summary>The angle of the caret when this font is used.</summary>		public float CaretAngle;		/// <summary>The horizontal caret offset.</summary>		public float CaretOffset;		/// <summary>The number of glyphs in this font face.</summary>		public int NumberOfHMetrics;		/// <summary>The glyph units per em value.</summary>		public int UnitsPerEm=1000;		/// <summary>The glyph units per em value, as a float.</summary>		public float UnitsPerEmF=1000f;		/// <summary>The thickness of a strikethrough line.</summary>		public float StrikeSize=0.1f;		/// <summary>The offset to a strikethrough line.</summary>		public float StrikeOffset=0.25f;		/// <summary>The font that this is a derivative of.</summary>		public FontFace SyntheticDerivative;		/// <summary>The flags for this font face. A style bitmask.</summary>		public FontFaceFlags StyleFlags=FontFaceFlags.Regular;		/// <summary>All raw glyphs in this font face. Indexed by charcode. Note that if you have Font.Preload false, they may not be loaded.		/// Check glyph.RequiresLoad if you access this directly.</summary>		public Dictionary<int,Glyph> Glyphs=new Dictionary<int,Glyph>();		/// <summary>The CFF parser, if this is a CFF format font. Used to load glyphs on demand.</summary>		public CffGlyphParser CffParser;		/// <summary>The raw parser. Used to load glyphs on demand.</summary>		public FontParser Parser;		/// <summary>Don't use this! Use Glyphs instead. The raw glyph set used by the parser. May be null.</summary>		internal Glyph[] ParserGlyphs;		/// <summary>The number of not yet loaded glyphs in this font.</summary>		public int UnloadedGlyphs;						/// <summary>Called when all glyphs in this font face have been loaded up.		/// Note that this may occur very late or, more likely never, when glyphs are loaded on demand.</summary>		public void AllGlyphsLoaded(){						CffParser=null;			Parser=null;			UnloadedGlyphs=0;			ParserGlyphs=null;					}				/// <summary>Figures out the winding order of this font face from the given glyph.</summary>		internal void FindWinding(Glyph glyph){						// No longer unknown:			WindingUnknown=false;						// Get the signed area:			float firstArea=glyph.GetSignedArea();						Clockness=(firstArea<=0f);						if(Family.InvertedNormals){				Clockness=!Clockness;			}					}				/// <summary>Inverts the normals of all glyphs in this font face.</summary>		public void InvertNormals(){						// Ensure we're ready for ones which haven't loaded their meta yet:			Clockness=!Clockness;						// And update the ones which have:			foreach(KeyValuePair<int,Glyph> kvp in Glyphs){								// Get the glyph:				Glyph glyph=kvp.Value;								// Invert if it's loaded:				if(glyph.Width!=0f){					glyph.MultiplyNormals(-1f);				}							}					}				/// <summary>Loads the glyph info for this font face now. See RequiresLoad.</summary>		public void Load(){			if(!RequiresLoad){				return;			}						RequiresLoad=false;			FontLoader.ReadTables(Parser,this);		}				/// <summary>Derives this font face from the given one, with the given settings.</summary>		public void Derive(FontFace from,bool italic,int weight){						// Flags and weight:			SetFlags(italic,weight);						SyntheticDerivative=from;						Clockness=from.Clockness;			WindingUnknown=from.WindingUnknown;						Family=from.Family;						Name=FamilyName+" (InfiniText Synthetic)";					}				/// <summary>Applies the angle, in degrees, used for synthesizing italic chars.</summary>		public void SetItalicAngle(float angle){						ItalicAngle=(float)Math.Tan(angle * Math.PI/180f);					}				/// <summary>Sets the weight of this face and if it's italic.</summary>		public void SetFlags(bool italic,int weight){						// Build the flags:			int flags=weight;						if(italic){				flags|=1;			}						// Apply the flags:			StyleFlags=(FontFaceFlags)flags;						// Apply weight:			Weight=weight;					}				/// <summary>Is this a synthetic font?</summary>		public bool Synthetic{			get{				return (SyntheticDerivative!=null);			}		}				/// <summary>Is this the regular font for this family?</summary>		public bool Regular{			get{				return (StyleFlags==FontFaceFlags.Regular);			}		}				/// <summary>True if this is an italic face.</summary>		public bool Italic{			get{				return (((int)StyleFlags&1)==1);			}		}				/// <summary>True if this is a bold face.</summary>		public bool Bold{			get{				// Not regular:				return ((StyleFlags&FontFaceFlags.Regular)!=FontFaceFlags.Regular);			}		}				/// <summary>Creates a synthetic derivative of this font. Used when a font does not have e.g. an italic face.</summary>		public FontFace CreateSynthetic(bool italic,int weight){						FontFace font=new FontFace();						font.Derive(this,italic,weight);						return font;					}				/// <summary>Synthesizes a glyph of the given charcode.</summary>		public Glyph Synthesize(int charCode){						if(SyntheticDerivative.RequiresLoad){				// Load it now:				SyntheticDerivative.Load();			}						Glyph baseGlyph;						if(!SyntheticDerivative.Glyphs.TryGetValue(charCode,out baseGlyph)){				return null;			}						if(baseGlyph.RequiresLoad){				baseGlyph.LoadNow();			}						// Make a copy of the glyph:			Glyph synthetic=baseGlyph.Copy();						// Push it in:			Glyphs[charCode]=synthetic;						if(Weight!=SyntheticDerivative.Weight){								// Go bold or thinner. "Pull" it out along the normals.				int delta=Weight-SyntheticDerivative.Weight;								float extrudeBy=0.01f*(delta/100f);								// We need the meta:				synthetic.RecalculateMeta();								synthetic.Extrude(extrudeBy);								// Expand the draw distances:				extrudeBy+=1f;								synthetic.AdvanceWidth*=extrudeBy;				synthetic.LeftSideBearing*=extrudeBy;							}						if(Italic && !SyntheticDerivative.Italic){								// Time to go italic! Sheer based on our fonts italic angle.				synthetic.Sheer(ItalicAngle);							}						// Make sure it knows to recompute the meta:			synthetic.Width=0f;						// All done!			return synthetic;					}				/// <summary>Gets a glyph for a particular charcode. Note that no glyphs are ever empty.</summary>		public Glyph GetGlyph(int charCode){						if(RequiresLoad){				// Load it now:				Load();			}						Glyph result;			if(!Glyphs.TryGetValue(charCode,out result)){								if(SyntheticDerivative!=null){					// Synthesize now.					result=Synthesize(charCode);				}							}else if(result.RequiresLoad){				result.LoadNow();			}						return result;					}				/// <summary>The name of the family this font is in. Set is for internal use only.</summary>		public string FamilyName{			get{				if(Family==null){					return null;				}								return Family.Name;			}			set{								// Get/ create the family:				Family=Fonts.GetOrCreate(value);								// Add to family:				Family.Add(this);							}		}			}}