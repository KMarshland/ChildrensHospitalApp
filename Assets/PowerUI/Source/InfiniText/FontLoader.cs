//--------------------------------------//             InfiniText////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;using System.IO;namespace InfiniText{	public static class FontLoader{				/// <summary>Creates a fontface from the given data. Only actually loads it on first glyph request.</summary>		public static FontFace DeferredLoad(byte[] data){						// Create the parser:			FontParser parser=new FontParser(data);						// Create the font:			FontFace font=new FontFace();						if(Load(parser,font,false)){				return font;			}else{				return null;			}					}				public static FontFace Load(byte[] data){						FontParser parser=new FontParser(data);						return Load(parser);					}				public static FontFace Load(FontParser parser){						// Create the font:			FontFace font=new FontFace();						if(Load(parser,font,true)){				return font;				}else{				return null;			}					}				public static bool Load(FontParser parser,FontFace font,bool full){						font.RequiresLoad=!full;			font.Parser=parser;						// Read the version:			int dec;			int version=parser.ReadFixed(out dec);						if(version == 1 && dec==0){								// TTF outline format.							}else{								// Reset to start:				parser.Position=0;								// OpenType. Read the tag (right at the start):				string openTypeVersion=parser.ReadTag();								if (openTypeVersion == "OTTO"){										// CFF outline format.									}else{										// Unsupported format.					return false;									}							}						// Table count:			int numTables=parser.ReadUInt16();						// Move to p12:			parser.Position=12;						for (int i=0;i<numTables;i++){								// Read the tables tag:				string tag=parser.ReadTag();								// Move parser along:				parser.Position+=4;								// Read the offset:				int offset=(int)parser.ReadUInt32();								// Grab the position - this allows the tables to mess it up:				int basePosition=parser.Position;								switch (tag){										case "cmap":												parser.CmapOffset=offset;											break;					case "head":												// Load the header:						if(!HeaderTables.Load(parser,offset,font,out parser.IndexToLocFormat)){							return false;						}											break;					case "hhea":												parser.HheaOffset = offset;											break;					case "hmtx":						parser.HmtxOffset = offset;					break;					case "maxp":												// Maxp table:						MaxpTables.Load(parser,offset,font,out parser.GlyphCount);											break;					case "name":												// General meta:						NameTables.Load(parser,offset,font);											break;					case "OS/2":												// OS2 table:						OS2Tables.Load(parser,offset,font);											break;					case "post":												// Postscript info table:						parser.PostOffset=offset;											break;					case "glyf":						parser.GlyfOffset=offset;					break;					case "loca":						parser.LocaOffset=offset;					break;					case "GSUB":												// Gsub(stitute) table. Ligatures fall through here.						GsubTables.Load(parser,offset,font);											break;					case "CFF ":						parser.CffOffset=offset;					break;					case "kern":												parser.KernOffset=offset;											break;					case "GPOS":												parser.GposOffset=offset;											break;									}								// Skip meta:				parser.Position=basePosition+4;			}						if(full){				return ReadTables(parser,font);			}					return true;			}		public static bool ReadTables(FontParser parser,FontFace font){						int hmMetricCount=0;						if(parser.HheaOffset!=0){								// Hhea table:				HheaTables.Load(parser,parser.HheaOffset,font,out hmMetricCount);							}						Glyph[] glyphs=null;						if(parser.GlyfOffset!=0 && parser.LocaOffset!=0){								bool shortVersion=(parser.IndexToLocFormat==0);								// Load a loca table (temporary):				uint[] locaTable=LocaTables.Load(parser,parser.LocaOffset,parser.GlyphCount,shortVersion);								// Load the glyph set:				glyphs=GlyfTables.Load(parser,parser.GlyfOffset,locaTable,font);								HmtxTables.Load(parser,parser.HmtxOffset,font,glyphs,hmMetricCount);							}else if(parser.CffOffset!=0){								if(parser.PostOffset!=0){										// Post table:					int postGlyphCount;					PostTables.Load(parser,parser.PostOffset,font,out postGlyphCount);										if(parser.GlyphCount==0 && postGlyphCount!=-1){												parser.GlyphCount=postGlyphCount;											}									}								// Load the CFF (PostScript glyph) table:				glyphs=CffTables.Load(parser,parser.CffOffset,font);							}else{								// Unrecognised/ bad font.				return false;							}						if(parser.KernOffset!=0){								// Kerning table:				KerningTables.Load(parser,parser.KernOffset,font,glyphs);							}else if(parser.GposOffset!=0){								// GPOS table (also kerning data):				GposTables.Load(parser,parser.GposOffset,font,glyphs);						}						// Finally, the character map:			if(parser.CmapOffset!=0){								// Load a charmap:				CharMapTables.Load(parser,parser.CmapOffset,font,glyphs);							}						if(Fonts.Preload){				font.AllGlyphsLoaded();			}						return true;		}			}}