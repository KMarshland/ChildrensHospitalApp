//--------------------------------------//               PowerUI////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;using UnityEngine;using System.Collections;using System.Collections.Generic;namespace PowerUI{	/// <summary>	/// A dynamic texture renders it's pixels in a custom way.	/// This can be considered similar to a canvas element.	/// This allows for some very dynamic graphics on the UI (for example, a curved health bar).	/// </summary>	public class DynamicTexture{				/// <summary>True if at least one dynamic texture must be flushed this frame.</summary>		public static bool SomethingToUpdate;		/// <summary>A global lookup of available dynamic textures used for mapping a URL to an object.		/// E.g. background:url("dynamic://healthbar");</summary>		public static Dictionary<string,DynamicTexture> Instances;				/// <summary>Gets a dynamic texture by name from the global lookup.</summary>		/// <param name="byName">The name of the dynamic texture.</param>		/// <returns>The dynamic texture if found; null otherwise.</returns>		public static DynamicTexture Get(string byName){			if(Instances==null){				return null;			}			DynamicTexture result;			Instances.TryGetValue(byName,out result);			return result;		}				/// <summary>Removes all dynamic textures.</summary>		public static void RemoveAll(){			SomethingToUpdate=false;			Instances=null;		}				/// <summary>Redraw requests are buffered and done in one go by this method.</summary>		public static void Update(){			if(!SomethingToUpdate){				return;			}			SomethingToUpdate=false;			foreach(KeyValuePair<string,DynamicTexture> kvp in Instances){				DynamicTexture texture=kvp.Value;				if(!texture.Refreshing){					continue;				}				texture.Redraw();			}		}				/// <summary>The width of the dynamic texture.</summary>		public int Width;		/// <summary>The height of the dynamic texture.</summary>		public int Height;		/// <summary>The name for this texture.</summary>		public string Name;		/// <summary>True if this texture needs a refresh this frame.</summary>		public bool Refreshing;		/// <summary>The pixels of this texture.</summary>		public Color32[] Pixels;		/// <summary>The resized height of the texture (internal). Only used if this texture is resized and it gets shrunk.</summary>		public int ResizedWidth;		/// <summary>The resized height of the texture (internal). Only used if this texture is resized and it gets shrunk.</summary>		public int ResizedHeight;		/// <summary>A placeholder texture which is only used by the atlas.</summary>		private Texture2D Texture;				/// <summary>Creates a new dynamic texture of the given dimensions.</summary>		/// <param name="width">The width of the texture.</param>		/// <param name="height">The height of the texture.</param>		/// <param name="name">The name of the texture. This is used in urls to locate it (e.g. dynamic://theName).</param>		public DynamicTexture(int width,int height,string name){			// Setup the texture:			Resize(width,height,true);						Name=name;						if(Instances==null){				Instances=new Dictionary<string,DynamicTexture>();			}						Instances[name]=this;		}				/// <summary>Creates an empty dynamic texture. Note that this is used internally by canvas.		/// If used, you must call Resize to set it up.</summary>		public DynamicTexture(){		}				/// <summary>Resize this texture on the X axis.</summary>		/// <param name="width">The new width.</param>		public void ResizeX(int width){			Resize(width,Height);		}				/// <summary>Resize this texture on the Y axis.</summary>		/// <param name="height">The new height.</param>		public void ResizeY(int height){			Resize(Width,height);		}				/// <summary>Resize this texture on the X and Y axis.</summary>		/// <param name="width">The new width.</param>		/// <param name="height">The new height.</param>		public void Resize(int width,int height){			Resize(width,height);		}				/// <summary>The filter mode of this dynamic texture. The default filtering is point.</summary>		public FilterMode FilterMode{			get{				return Texture.filterMode;			}			set{				Texture.filterMode=value;			}		}				/// <summary>Resize this texture on the X and Y axis, optionally only doing so if dimensions aren't zero.</summary>		/// <param name="width">The new width.</param>		/// <param name="height">The new height.</param>		/// <param name="createIfZero">Only do the resize if the dimensions are non-zero.</param>		public void Resize(int width,int height,bool createIfZero){			if(width==0 || height==0){				if(!createIfZero){					return;				}			}						if(width<=Width && height<=Height){				// It actually shrunk so no need to recreate the texture itself.				Height=height;				Width=width;				return;			}						// Apply the width and height:			Width=width;			Height=height;			ResizedWidth=width;			ResizedHeight=height;						// Create the texture:			Texture=new Texture2D(width,height,TextureFormat.ARGB32,false);						Texture.filterMode=FilterMode.Point;						// Setup the pixels:			Pixels=Texture.GetPixels32();			Clear();		}				/// <summary>Gets the texture.</summary>		public Texture2D GetTexture(){			return Texture;		}				/// <summary>Gets the placeholder texture.</summary>		[Obsolete("GetTextureHolder is deprecated. Please use GetTexture instead.")]		public Texture2D GetTextureHolder(){			return Texture;		}				/// <summary>Draws a pixel at the given x/y coordinates to the atlas.</summary>		/// <param name="x">The x coordinate in pixels from the left of the texture.</param>		/// <param name="y">The y coordinate in pixels from the bottom of the texture.</param>		/// <param name="colour">The colour of the pixel to draw.</param>		public void DrawPixel(int x,int y,Color32 colour){			if(x<0 || x>=Width || y<0 || y>=Height){				return;			}			SetPixel((y*ResizedWidth)+x,colour);		}				/// <summary>Draws a line on the atlas from one point to another.</summary>		/// <param name="x">The x coordinate in pixels from the left of the start of the line.</param>		/// <param name="y">The y coordinate in pixels from the left of the start of the line.</param>		/// <param name="x2">The x coordinate in pixels from the left of the end of the line.</param>		/// <param name="y2">The y coordinate in pixels from the left of the end of the line.</param>		/// <param name="colour">The colour of the line.</param>		public void DrawLine(int x,int y,int x2, int y2,Color32 colour){			int w=x2-x;			int h=y2-y;			int dx1=0;			int dy1=0;			int dx2=0;			int dy2=0;						if(w<0){				dx1=-1;			}else if(w>0){				dx1=1;			}			dx2=dx1;						if(h<0){				dy1=-1;			}else if(h>0){				dy1=1;			}						if(w<0){				w=-w;			}						if(h<0){				h=-h;			}						if(w<=h){				int flip=w;				w=h;				h=flip;				dy2=dy1;				dx2=0;           			}						int numerator=w>>1;			for(int i=0;i<=w;i++){				DrawPixel(x,y,colour);				numerator+=h;				if(numerator>=w){					numerator-=w;					x+=dx1;					y+=dy1;				}else{					x+=dx2;					y+=dy2;				}			}		}				/// <summary>Draws a filled circle on the atlas.</summary>		/// <param name="x0">The x coordinate of the circles center in pixels from the left.</param>		/// <param name="y0">The y coordinate of the circles center in pixels from the bottom.</param>		/// <param name="radius">The radius of the circle, in pixels.</param>		/// <param name="colour">The colour of the circle.</param>		public void DrawCircle(int x0, int y0, int radius,Color32 colour){			int y=0;			int x=radius;			int yChange=0;			int radiusError=0;			int xChange=1-radius*2;						while(x>=y){				// Filled circle:				DrawLine(x + x0, y + y0,-x + x0, y + y0,colour);				DrawLine(y + x0, x + y0,-y + x0, x + y0,colour);				DrawLine(-y + x0, -x + y0,y + x0, -x + y0,colour);				DrawLine(-x + x0, -y + y0,x + x0, -y + y0,colour);								y++;				radiusError+=yChange;				yChange+=2;				if(((radiusError<<1)+xChange)>0){					x--;					radiusError+=xChange;					xChange+=2;				}			}		}				/// <summary>Wipes the graphic clean using transparent black.</summary>		public void Clear(){			Clear(new Color32(0,0,0,0));		}				/// <summary>Wipes the graphic clean.</summary>		/// <param name="clearColour">The colour to set the whole graphic to.</param>		public void Clear(Color32 clearColour){			for(int y=0;y<Height;y++){				int yIndex=(y*ResizedWidth);								for(int x=0;x<Width;x++){					SetPixel(x+yIndex,clearColour);				}			}		}				/// <summary>Sets a the colour of a particular global pixel on the atlas.</summary>		/// <param name="index">The global index of the pixel on the atlas.</param>		/// <param name="colour">The colour of the pixel to set.</param>		public void SetPixel(int index,Color32 colour){			Pixels[index]=colour;		}				/// <summary>Called to refresh the texture.</summary>		public void Refresh(){			Refreshing=true;			SomethingToUpdate=true;		}				/// <summary>Called by the update system to redraw this texture, only if it requires it.</summary>		private void Redraw(){			if(!Refreshing){				return;			}			Refreshing=false;			Flush();			Texture.SetPixels32(Pixels);						// Upload changes:			Texture.Apply(false);		}				/// <summary>Override this to write to the pixels. Should internally use SetPixel for this.</summary>		public virtual void Flush(){}				/// <summary>Internally used only. Flushes the pixel array to the texture right now.</summary>		public void FlushDirect(){			// Apply the pixels:			Texture.SetPixels32(Pixels);						// Upload changes:			Texture.Apply(false);		}			}	}