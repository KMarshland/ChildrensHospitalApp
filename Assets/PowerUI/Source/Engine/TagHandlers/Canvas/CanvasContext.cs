//--------------------------------------//               PowerUI////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;using PowerUI.Css;using UnityEngine;using System.Collections;using System.Collections.Generic;using Blaze;using InfiniText;namespace PowerUI{		/// <summary>	/// Represents a canvas context which lets you draw 2D shapes and polygons on the UI.	/// See the canvas html tag for more information.	/// </summary>		public class CanvasContext{				/// <summary>The rasteriser used to fill with.</summary>		public Scanner Rasteriser;						/// <summary>The underlying path.</summary>		public VectorPath Path;		/// <summary>The tag handler for the canvas that this is a context for.</summary>		private CanvasTag Canvas;		/// <summary>A package containing the dynamic image. This is used to actually display the image		/// on screen.</summary>		public ImagePackage Package;		/// <summary>The target rendering plane.</summary>		public DynamicTexture ImageData;		/// <summary>The current fill colour. See fillStyle. Default is black.</summary>		public Color32 FillColour=new Color32(0,0,0,255);		/// <summary>The current stroke colour. See strokeStyle. Default is black.</summary>		public Color32 StrokeColour=new Color32(0,0,0,255);						/// <summary>Creates a new canvas context for the given canvas element.</summary>		/// <param name="canvas">The canvas handler for a particular canvas element.</param>		public CanvasContext(CanvasTag tag){			// Apply the tag:			Canvas=tag;						Path=new VectorPath();		}				/// <summary>Creates an infinitext glyph from the path you've just made.</summary>		public Glyph ToGlyph(){						Glyph glyph=new Glyph();						glyph.FirstPathNode=Path.FirstPathNode;			glyph.LatestPathNode=Path.LatestPathNode;			glyph.PathNodeCount=Path.PathNodeCount;						// Compute the meta:			glyph.RecalculateMeta();						// Squish it to being at most 1 unit tall:			if(glyph.Height>1f){								glyph.Scale(1f/glyph.Height);							}						// Setup a default advance width:			glyph.AdvanceWidth=glyph.Width;						// Clear the path:			Path.Clear();						return glyph;					}				/// <summary>Starts creating a path on this context. Used to draw and fill in any kind of shape.</summary>		public void beginPath(){			// Just clear the path:			Path.Clear();		}				/// <summary>Closes the current path such that it forms a loop by drawing a line to the first node.</summary>		public void closePath(){			Path.ClosePath();		}				/// <summary>The current number of nodes on the current path.</summary>		public int PathNodeCount{			get{				return Path.PathNodeCount;			}		}				/// <summary>Adds a line from the current pen location to the given point. Note that nothing will		/// be seen until you call a fill or stroke method.</summary>		public void lineTo(float x,float y){						if(Path.PathNodeCount==0){								Path.MoveTo(0f,0f);							}						Path.LineTo(x,y);		}				/// <summary>Creates an arc around the given circle center. Note that nothing will		/// be seen until you call a fill or stroke method.</summary>		public void arc(float centerX,float centerY,float radius,float sAngle,float eAngle){			arc(centerX,centerY,radius,sAngle,eAngle,false);		}				/// <summary>Creates an arc around the given circle center. Note that nothing will		/// be seen until you call a fill or stroke method.</summary>		public void arc(float centerX,float centerY,float radius,float sAngle,float eAngle,bool counterClockwise){						VectorPoint previous=Path.LatestPathNode;						float x0;			float y0;						if(previous==null){				x0=0f;				y0=0f;			}else{				x0=previous.X;				y0=previous.Y;			}						// Clockwise eAngle > sAngle; counter clockwise otherwise.			if(eAngle>sAngle){				if(counterClockwise){					// Get them both in range:					eAngle=eAngle%(Mathf.PI*2f);					sAngle=sAngle%(Mathf.PI*2f);										// Reduce eAngle by a full rotation so it's smaller:					eAngle-=(Mathf.PI*2f);				}			}else if(!counterClockwise){				// Get them both in range:				eAngle=eAngle%(Mathf.PI*2f);				sAngle=sAngle%(Mathf.PI*2f);									// Reduce sAngle by a full rotation so it's smaller:				sAngle-=(Mathf.PI*2f);			}									// First, figure out where the actual start is.			// It's radius units to the right of center, then rotated through radius around center.			// Thus we have a triangle with hyp length of 'radius' and an angle of sAngle:			float startX=radius * (float) Math.Cos(sAngle);			float startY=radius * (float) Math.Sin(sAngle);						// Now find the end point, using exactly the same method:			float endX=radius * (float) Math.Cos(eAngle);			float endY=radius * (float) Math.Sin(eAngle);						// We now have an arc from the current position to endX/endY.			// The start and exit node angles are usefully just offset from the given ones.			// This is because an sAngle of zero should create an arc which starts travelling downwards.			// (Or upwards if it's counter clockwise):						// Where does the arc start from?			float arcStartX=centerX+startX;			float arcStartY=centerY+startY;						if(Path.FirstPathNode==null){				// This occurs if the arc is the first thing we draw. No line is drawn to it.				Path.MoveTo(arcStartX,arcStartY);			}else if(arcStartX!=x0 || arcStartY!=y0){				// Draw a line to this point:				Path.LineTo(arcStartX,arcStartY);			}						// Create the new arc node:			ArcLinePoint arcNode=new ArcLinePoint(centerX+endX,centerY+endY);						// Apply the radius:			arcNode.Radius=radius;						// Apply the angles:			arcNode.StartAngle=sAngle;			arcNode.EndAngle=eAngle;						// Apply the center:			arcNode.CircleCenterX=centerX;			arcNode.CircleCenterY=centerY;						// Add the other end:			Path.AddPathNode(arcNode);					}				/// <summary>Is the specified point in (not on) the current path?</summary>		/// <param name="x">The x coordinate.</param>		/// <param name="y">The y coordinate.</param>		public bool isPointInPath(float x,float y){			VectorPoint node=Path.FirstPathNode;						// For each one..			while(node!=null){								// Got a match?				if(node.X==x && node.Y==y){					return true;				}								// Hop to the next one:				node=node.Next;							}						return false;		}				public void curveTo(float c1x,float c1y,float c2x,float c2y,float x,float y){			Path.CurveTo(c1x,c1y,c2x,c2y,x,y);		}				public void quadraticCurveTo(float cx,float cy,float x,float y){			Path.QuadraticCurveTo(cx,cy,x,y);		}				/// <summary>Adds an arc between the given points using the pen point as a control point. 		/// Note that nothing will be seen until you call a fill or stroke method.</summary>		public void arcTo(float x1,float y1,float x2,float y2,float radius){						VectorPoint previous=Path.LatestPathNode;						float x0;			float y0;						if(previous==null){				x0=0f;				y0=0f;			}else{				x0=previous.X;				y0=previous.Y;			}						// How this works:			// Line from 0->1.			// Another from 2->1, thus forming a 'triangle'.			// Slide a circle of the given radius in this triangle such that it's			// as far in as it will go whilst just touching both lines.			// Draw an arc from the two intersection points of the circle with the triangle.						// What we need to find:			// - Circle center.			// - The start and end angles. Always clockwise.						// Create the new arc node:			ArcLinePoint arcNode=new ArcLinePoint(x2,y2);						// Apply the radius:			arcNode.Radius=radius;						// First find the angle of 1 from +ve x. This is just an Atan2 call:			float angleLine2=(float)Math.Atan2(y0-y1,x0-x1);						// Find the angle of 2 relative to 1.			// As we know the angle of 1 relative to +ve x, we can find 1 relative to +ve x			// and then grab the difference.			float rotateThrough=(float)Math.Atan2(y2-y1,x2-x1)-angleLine2;						// Find half of the angle:			float halfAngle=rotateThrough/2f;						// What's the distance of point 1 to the circle center?			float distanceToCenter=radius/(float)Math.Cos(halfAngle);						// Resolve the x coordinate of the center:			arcNode.CircleCenterX=(distanceToCenter * (float) Math.Cos(halfAngle - angleLine2)) + x1;						// Resolve the y coordinate of the center:			arcNode.CircleCenterY=(distanceToCenter * (float) Math.Sin(halfAngle - angleLine2)) + y1;						// Apply the angles:			arcNode.StartAngle= - rotateThrough - angleLine2;			arcNode.EndAngle=arcNode.StartAngle - rotateThrough;						float arcStartNodeX;			float arcStartNodeY;			arcNode.SampleAt(0f,out arcStartNodeX,out arcStartNodeY);						float arcEndNodeX;			float arcEndNodeY;			arcNode.SampleAt(1f,out arcEndNodeX,out arcEndNodeY);						if(Path.FirstPathNode==null){				// This occurs if the arc is the first thing we draw. No line is drawn to it.				Path.MoveTo(arcStartNodeX,arcStartNodeY);			}else if(x0!=arcStartNodeX || y0!=arcStartNodeY){				Path.LineTo(arcStartNodeX,arcStartNodeY);			}						// Apply the node location:			arcNode.X=arcEndNodeX;			arcNode.Y=arcEndNodeY;						// Add the other end:			Path.AddPathNode(arcNode);					}				/// <summary>Gets the signed angle from one vector, the first, to another.</summary>		public float Angle(float x0,float y0,float x1,float y1){			float dot=Vector2.Dot(new Vector2(x0,y0),new Vector2(x1,y1));			return (float)Math.Atan2(Vector3.Cross(new Vector3(x0,y0,0f),new Vector3(x1,y1,0f)).magnitude,dot);		}				/// <summary>Draws the outline of path you created, and doesn't reset the path, using the stroke style.</summary>		public void stroke(){						// For each line..						VectorPoint node=Path.FirstPathNode;						// For each one..			while(node!=null){								// Render it as a line (if it has one; checks internally):				if(node.HasLine){										// Render the line from the next nodes point of view:					node.RenderLine(this);									}								// Hop to the next one:				node=node.Next;							}					}				/// <summary>Fills the current path with a solid colour. The colour used originates from the fillStyle.</summary>		public void fill(){						if(Path.FirstPathNode==null || ImageData==null){				return;			}						if(Rasteriser==null){								// Setup and start the rasteriser:				Rasteriser=new Scanner();				Rasteriser.SDFSize=0;				Rasteriser.ScaleY=-1f;				Rasteriser.Start();							}						// Figure out bounds:			Path.RecalculateBounds();						int rWidth=ImageData.Width;			int rHeight=ImageData.Height;						Rasteriser.Rasterise(Path,ImageData.Pixels,rWidth,0,rWidth,rHeight,0f,-rHeight,FillColour,false);					}				/// <summary>Moves the current pen location to the given point. Used when drawing paths.</summary>		public void moveTo(float x,float y){						Path.MoveTo(x,y);					}				/// <summary>Applies the image data so it's ready for rendering.</summary>		public void ApplyImageData(){			// Grab the canvas:			Element element=canvas;						// Grab its computed style:			ComputedStyle computed=element.style.Computed;						if(ImageData==null){				ImageData=new DynamicTexture();			}						// Resize the texture:			ImageData.Resize(computed.PixelWidth,computed.PixelHeight,false);						if(ImageData.Width!=0 && ImageData.Height!=0){								if(Package==null){					//We now need a package to actually display it.										// Create the package:					Package=new ImagePackage(ImageData);										// Apply it to the element:					if(computed.BGImage==null){						computed.BGImage=new BackgroundImage(element);					}					computed.BGImage.SetImage(Package);									}								// Run the change event:				element.Run("onchange");								apply();			}					}				/// <summary>Forces any changes to be applied right now.</summary>		public void apply(){			// Flush any changes:			ImageData.FlushDirect();		}				/// <summary>The canvas element that this is the context for.</summary>		public Element canvas{			get{				return Canvas.Element;			}		}				/// <summary>Applies the current fill style.</summary>		public string fillStyle{			set{								// Apply the colour:				FillColour=Value.GetColour(value);							}			get{				return "";			}		}				/// <summary>Applies the current stroke style.</summary>		public string strokeStyle{			set{								// Apply the colour:				StrokeColour=Value.GetColour(value);							}			get{				return "";			}		}				/// <summary>Called when the element is resized.</summary>		public void Resized(){			ApplyImageData();		}				/// <summary>The width of the canvas context.</summary>		public int width{			get{				if(ImageData==null){					return 0;				}								return ImageData.Width;			}			set{				if(ImageData==null){					ImageData=new DynamicTexture();				}				ImageData.ResizeX(value);			}		}				/// <summary>The height of the canvas context.</summary>		public int height{			get{				if(ImageData==null){					return 0;				}								return ImageData.Height;			}			set{				if(ImageData==null){					ImageData=new DynamicTexture();				}				ImageData.ResizeY(value);			}		}				/// <summary>Useful method to clear the whole context.</summary>		public void clear(){			if(ImageData!=null){				ImageData.Clear();			}						Path.Clear();		}				/// <summary>Clears the specified region of the canvas.</summary>		public void clearRect(int xStart,int yStart,int width,int height){			fillRect(xStart,yStart,width,height,new Color32(0,0,0,0));		}				/// <summary>Fills the specified box region using the current fillStyle.</summary>		public void fillRect(int xStart,int yStart,int width,int height){			fillRect(xStart,yStart,width,height,FillColour);		}				/// <summary>Fills the specified box region using the given colour.</summary>		public void fillRect(int xStart,int yStart,int rectWidth,int rectHeight,Color32 colour){			if(ImageData==null){				return;			}						// First invert y. This is because the canvas API is from the top left corner.			int yEnd=ImageData.Height-yStart;						int xEnd=xStart+rectWidth;			yStart=yEnd-rectHeight;						// Clip the region to the available space:			if(xStart<0){				xStart=0;			}						if(yStart<0){				yStart=0;			}						if(xEnd>ImageData.Width){				xEnd=ImageData.Width;			}						if(yEnd>ImageData.Height){				yEnd=ImageData.Height;			}						// Fill each pixel:			for(int y=yStart;y<yEnd;y++){				// Get the index of this row of pixels.				int index=(y*ImageData.ResizedWidth);								for(int x=xStart;x<xEnd;x++){					ImageData.SetPixel(x+index,colour);				}			}		}			}	}