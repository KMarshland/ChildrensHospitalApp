//--------------------------------------//               PowerUI////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;using PowerUI.Css;using UnityEngine;using System.Collections;using System.Collections.Generic;namespace PowerUI{		/// <summary>	/// Represents a canvas context which lets you draw 2D shapes and polygons on the UI.	/// See the canvas html tag for more information.	/// </summary>		public class CanvasContext{				/// <summary>The current number of edges on the current path.</summary>		public int PathEdgeCount;		/// <summary>The tag handler for the canvas that this is a context for.</summary>		private CanvasTag Canvas;		/// <summary>The current number of nodes on the current path.</summary>		public int PathNodeCount;		/// <summary>The current x location of the path pen. Use moveTo to safely relocate this.</summary>		public float CurrentPenX;		/// <summary>The current y location of the path pen. Use moveTo to safely relocate this.</summary>		public float CurrentPenY;		/// <summary>A package containing the dynamic image. This is used to actually display the image		/// on screen.</summary>		public ImagePackage Package;		/// <summary>The target rendering plane.</summary>		public DynamicTexture ImageData;		/// <summary>When creating a path its nodes are stored as a linked list. The first node created.</summary>		public CanvasPathNode FirstPathNode;		/// <summary>When creating a path its nodes are stored as a linked list. The latest node created.</summary>		public CanvasPathNode LatestPathNode;		/// <summary>The current fill colour. See fillStyle. Default is black.</summary>		public Color32 FillColour=new Color32(0,0,0,255);		/// <summary>The current stroke colour. See strokeStyle. Default is black.</summary>		public Color32 StrokeColour=new Color32(0,0,0,255);						/// <summary>Creates a new canvas context for the given canvas element.</summary>		/// <param name="canvas">The canvas handler for a particular canvas element.</param>		public CanvasContext(CanvasTag tag){			// Apply the tag:			Canvas=tag;		}				/// <summary>Starts creating a path on this context. Used to draw and fill in any kind of shape.</summary>		public void beginPath(){			FirstPathNode=LatestPathNode=null;			PathNodeCount=0;			PathEdgeCount=0;		}				/// <summary>Closes the current path such that it forms a loop by drawing a line to the first node.</summary>		public void closePath(){			if(FirstPathNode==null){				return;			}						lineTo(FirstPathNode.X,FirstPathNode.Y);		}				/// <summary>Used internally. Adds the given path node to the current path being created.</summary>		/// <param name="node">The node to add to the path.</param>		public void AddPathNode(CanvasPathNode node){						PathNodeCount++;						if(FirstPathNode==null){				LatestPathNode=FirstPathNode=node;				return;			}						node.Previous=LatestPathNode;			LatestPathNode=LatestPathNode.Next=node;		}				/// <summary>Adds a line from the current pen location to the given point. Note that nothing will		/// be seen until you call a fill or stroke method.</summary>		public void lineTo(float x,float y){			PathEdgeCount++;						if(HasMoved){				// We need to add the first end:				AddPathNode(new CanvasPathNode(CurrentPenX,CurrentPenY));			}						// Create the straight line:			CanvasStraightLineNode newNode=new CanvasStraightLineNode(x,y);						// Add it:			AddPathNode(newNode);						// Setup the node:			newNode.Setup();						// Move the pen:			CurrentPenX=x;			CurrentPenY=y;		}				/// <summary>Creates an arc around the given circle center. Note that nothing will		/// be seen until you call a fill or stroke method.</summary>		public void arc(float centerX,float centerY,float radius,float sAngle,float eAngle,bool counterClockwise){						// Clockwise eAngle > sAngle; counter clockwise otherwise.			if(eAngle>sAngle){				if(counterClockwise){					// Get them both in range:					eAngle=eAngle%(Mathf.PI*2f);					sAngle=sAngle%(Mathf.PI*2f);										// Reduce eAngle by a full rotation so it's smaller:					eAngle-=(Mathf.PI*2f);				}			}else if(!counterClockwise){				// Get them both in range:				eAngle=eAngle%(Mathf.PI*2f);				sAngle=sAngle%(Mathf.PI*2f);									// Reduce sAngle by a full rotation so it's smaller:				sAngle-=(Mathf.PI*2f);			}									// First, figure out where the actual start is.			// It's radius units to the right of center, then rotated through radius around center.			// Thus we have a triangle with hyp length of 'radius' and an angle of sAngle:			float startX=radius * (float) Math.Cos(sAngle);			float startY=radius * (float) Math.Sin(sAngle);						// Now find the end point, using exactly the same method:			float endX=radius * (float) Math.Cos(eAngle);			float endY=radius * (float) Math.Sin(eAngle);						// We now have an arc from the current position to endX/endY.			// The start and exit node angles are usefully just offset from the given ones.			// This is because an sAngle of zero should create an arc which starts travelling downwards.			// (Or upwards if it's counter clockwise):						PathEdgeCount++;						// Where does the arc start from?			float arcStartX=centerX+startX;			float arcStartY=centerY+startY;						if(FirstPathNode==null){				// This occurs if the arc is the first thing we draw. No line is drawn to it.				AddPathNode(new CanvasPathNode(arcStartX,arcStartY));			}else if(arcStartX!=CurrentPenX || arcStartY!=CurrentPenY){				// Draw a line to this point:				lineTo(arcStartX,arcStartY);			}						// Move the pen:			CurrentPenX=centerX+endX;			CurrentPenY=centerY+endY;						// Create the new arc node:			CanvasArcNode arcNode=new CanvasArcNode(CurrentPenX,CurrentPenY);						// Apply the radius:			arcNode.Radius=radius;						// Apply the angles:			arcNode.StartAngle=sAngle;			arcNode.EndAngle=eAngle;						// Apply the center:			arcNode.CircleCenterX=centerX;			arcNode.CircleCenterY=centerY;						// Add the other end:			AddPathNode(arcNode);						// Set it up now:			arcNode.Setup();					}				/// <summary>Is the specified point in (not on) the current path?</summary>		/// <param name="x">The x coordinate.</param>		/// <param name="y">The y coordinate.</param>		public bool isPointInPath(float x,float y){			CanvasPathNode node=FirstPathNode;						// For each one..			while(node!=null){				// Got a match?				if(node.X==x && node.Y==y){					return true;				}								// Hop to the next one:				node=node.Next;							}						return false;		}				/// <summary>Adds an arc between the given points using the pen point as a control point. 		/// Note that nothing will be seen until you call a fill or stroke method.</summary>		public void arcTo(float x1,float y1,float x2,float y2,float radius){						float x0=CurrentPenX;			float y0=CurrentPenY;						PathEdgeCount++;						// How this works:			// Line from 0->1.			// Another from 2->1, thus forming a 'triangle'.			// Slide a circle of the given radius in this triangle such that it's			// as far in as it will go whilst just touching both lines.			// Draw an arc from the two intersection points of the circle with the triangle.						// What we need to find:			// - Circle center.			// - The start and end angles. Always clockwise.						// Create the new arc node:			CanvasArcNode arcNode=new CanvasArcNode();									// Apply the radius:			arcNode.Radius=radius;						// First find the angle of 1 from +ve x. This is just an Atan2 call:			float angleLine2=(float)Math.Atan2(y0-y1,x0-x1);						// Find the angle of 2 relative to 1.			// As we know the angle of 1 relative to +ve x, we can find 1 relative to +ve x			// and then grab the difference.			float rotateThrough=(float)Math.Atan2(y2-y1,x2-x1)-angleLine2;						// Find half of the angle:			float halfAngle=rotateThrough/2f;						// What's the distance of point 1 to the circle center?			float distanceToCenter=radius/(float)Math.Cos(halfAngle);						// Resolve the x coordinate of the center:			arcNode.CircleCenterX=(distanceToCenter * (float) Math.Cos(halfAngle - angleLine2)) + x1;						// Resolve the y coordinate of the center:			arcNode.CircleCenterY=(distanceToCenter * (float) Math.Sin(halfAngle - angleLine2)) + y1;						fillRect((int)arcNode.CircleCenterX,(int)arcNode.CircleCenterY,1,1);						// Apply the angles:			arcNode.StartAngle= - rotateThrough - angleLine2;			arcNode.EndAngle=arcNode.StartAngle - rotateThrough;						Vector2 arcStartNode=arcNode.SampleAt(arcNode.StartAngle);			Vector2 arcEndNode=arcNode.SampleAt(arcNode.EndAngle);						if(FirstPathNode==null){				// This occurs if the arc is the first thing we draw. No line is drawn to it.				AddPathNode(new CanvasPathNode(arcStartNode.x,arcStartNode.y));			}else if(CurrentPenX!=arcStartNode.x || CurrentPenY!=arcStartNode.y){				lineTo(arcStartNode.x,arcStartNode.y);			}						// Apply the node location:			CurrentPenX=arcNode.X=arcEndNode.x;			CurrentPenY=arcNode.Y=arcEndNode.y;						// Add the other end:			AddPathNode(arcNode);						// Set it up now:			arcNode.Setup();		}				/// <summary>Gets the signed angle from one vector, the first, to another.</summary>		public float Angle(float x0,float y0,float x1,float y1){			float dot=Vector2.Dot(new Vector2(x0,y0),new Vector2(x1,y1));			return (float)Math.Atan2(Vector3.Cross(new Vector3(x0,y0,0f),new Vector3(x1,y1,0f)).magnitude,dot);		}				/// <summary>Draws the outline of path you created, and doesn't reset the path, using the stroke style.</summary>		public void stroke(){						// For each line..						CanvasPathNode node=FirstPathNode;						// For each one..			while(node!=null){								// Render it as a line (if it has one; checks internally):				if(node.IsLineAfter){					// Hop to the next one:					node=node.Next;										// Render the line from the next nodes point of view:					node.RenderLine(this);				}else{					// Hop to the next one:					node=node.Next;				}							}					}				/// <summary>Fills the current path with a solid colour. The colour used originates from the fillStyle.</summary>		public void fill(){						if(LatestPathNode==null){				return;			}						// First, find the bounds of each line.			CanvasPathNode node=FirstPathNode;						// For each one..			while(node!=null){								// Is there a line here?				if(node.IsLineAfter){					// Hop to the next one:					node=node.Next;										// Calculate it's bounds:					node.RecalculateBounds();				}else{					// Hop to the next one:					node=node.Next;				}							}						// We're going to draw scan lines starting from minimum Y. By sorting them, we have to check less lines.			// Next, sort the lines by their maximum Y value, in ascending order.						//CanvasPathNode smallestY=null;			//CanvasPathNode biggestY=null;					}				/// <summary>Has the pen moved in some way? If so, any new lines need to add two points.</summary>		private bool HasMoved{			get{				if(LatestPathNode==null){					return true;				}								return (LatestPathNode.X!=CurrentPenX || LatestPathNode.Y!=CurrentPenY);			}		}				/// <summary>Moves the current pen location to the given point. Used when drawing paths.</summary>		public void moveTo(float x,float y){			CurrentPenX=x;			CurrentPenY=y;		}				/// <summary>Applies the image data so it's ready for rendering.</summary>		public void ApplyImageData(){			// Grab the canvas:			Element element=canvas;						// Grab its computed style:			ComputedStyle computed=element.style.Computed;						if(ImageData==null){				ImageData=new DynamicTexture();			}						// Resize the texture:			ImageData.Resize(computed.PixelWidth,computed.PixelHeight,false);						if(ImageData.Width!=0 && ImageData.Height!=0){								if(Package==null){					//We now need a package to actually display it.										// Create the package:					Package=new ImagePackage(ImageData);										// Apply it to the element:					if(computed.BGImage==null){						computed.BGImage=new BackgroundImage(element);					}					computed.BGImage.SetImage(Package);									}								// Run the change event:				element.Run("onchange");								apply();			}					}				/// <summary>Forces any changes to be applied right now.</summary>		public void apply(){			// Flush any changes:			ImageData.FlushDirect();		}				/// <summary>The canvas element that this is the context for.</summary>		public Element canvas{			get{				return Canvas.Element;			}		}				/// <summary>Applies the current fill style.</summary>		public string fillStyle{			set{							}		}				/// <summary>Called when the element is resized.</summary>		public void Resized(){			ApplyImageData();		}				/// <summary>The width of the canvas context.</summary>		public int width{			get{				if(ImageData==null){					return 0;				}								return ImageData.Width;			}			set{				if(ImageData==null){					ImageData=new DynamicTexture();				}				ImageData.ResizeX(value);			}		}				/// <summary>The height of the canvas context.</summary>		public int height{			get{				if(ImageData==null){					return 0;				}								return ImageData.Height;			}			set{				if(ImageData==null){					ImageData=new DynamicTexture();				}				ImageData.ResizeY(value);			}		}				/// <summary>Useful method to clear the whole context.</summary>		public void clear(){			if(ImageData!=null){				ImageData.Clear();			}		}				/// <summary>Clears the specified region of the canvas.</summary>		public void clearRect(int xStart,int yStart,int width,int height){			fillRect(xStart,yStart,width,height,new Color32(0,0,0,0));		}				/// <summary>Fills the specified box region using the current fillStyle.</summary>		public void fillRect(int xStart,int yStart,int width,int height){			fillRect(xStart,yStart,width,height,FillColour);		}				/// <summary>Fills the specified box region using the given colour.</summary>		public void fillRect(int xStart,int yStart,int rectWidth,int rectHeight,Color32 colour){			if(ImageData==null){				return;			}						// First invert y. This is because the canvas API is from the top left corner.			int yEnd=ImageData.Height-yStart;						int xEnd=xStart+rectWidth;			yStart=yEnd-rectHeight;						// Clip the region to the available space:			if(xStart<0){				xStart=0;			}						if(yStart<0){				yStart=0;			}						if(xEnd>ImageData.Width){				xEnd=ImageData.Width;			}						if(yEnd>ImageData.Height){				yEnd=ImageData.Height;			}						// Fill each pixel:			for(int y=yStart;y<yEnd;y++){				// Get the index of this row of pixels.				int index=(y*ImageData.ResizedWidth);								for(int x=xStart;x<xEnd;x++){					ImageData.SetPixel(x+index,colour);				}			}		}			}	}