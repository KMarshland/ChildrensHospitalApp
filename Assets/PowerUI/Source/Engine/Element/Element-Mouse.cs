//--------------------------------------//               PowerUI////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;using PowerUI.Css;namespace PowerUI{		/// <summary>	/// This function is called when a @font-face font is done loading.	/// </summary>	public partial class Element{						/// <summary>True if the mouse is over this element. Most accurate compared to MousedOver, but is more intensive.		/// In general, only use this one from within onmouseover or onmouseout.</summary>		public bool IsMousedOver(){			UnityEngine.Vector2 point=Input.MousePosition;			return Style.Computed.Contains((int)point.x,(int)point.y);		}				/// <summary>Let the element know the mouse has moved over it.</summary>		/// <param name="mouseEvent">The UIEvent that represents where the mouse is.</param>		/// <returns>True if this element accepts the mouse; false otherwise.</returns>		public bool MouseOver(UIEvent mouseEvent){						// Text (TextElement) or variable (VariableElement) elements must not run a mouseover:			if(GetType()!=typeof(Element)){				return false;			}						if(Input.MouseOvers.Count>mouseEvent.bubbleCount){				if(Input.MouseOvers[mouseEvent.bubbleCount]!=this){					Input.ClearMouseOvers(mouseEvent,mouseEvent.bubbleCount);					Input.MouseOvers.Add(this);				}else{					// Just bump up bubble count:					mouseEvent.bubbleCount++;										// Just re-broadcast the previous event state.					return (MousedOver==MouseOverState.OverConsumed);				}			}else{				Input.MouseOvers.Add(this);			}						mouseEvent.bubbleCount++;						bool result=false;						// Update css:			if(Style.Computed.Hover()){				result=true;			}						// Set the tooltip, if we've got one:			string title=this["title"];						if(title!=null){				Document.tooltip=title;			}						mouseEvent.target=this;			Document.window.Event=mouseEvent;						if(this["onmouseover"]!=null){				Run("onmouseover",mouseEvent);				result=true;			}						if(OnMouseOver!=null){				OnMouseOver(mouseEvent);				result=true;			}						if(!result){				result=HasBackground;			}						if(result){				MousedOver=MouseOverState.OverConsumed;			}else{				MousedOver=MouseOverState.Over;			}						return result;		}				/// <summary>Let the element know the mouse is no longer over it.</summary>		/// <param name="mouseEvent">The UIEvent that represents where the mouse is.</param>		public void MouseOut(UIEvent mouseEvent){			if(MousedOver==MouseOverState.Out){				return;			}						MousedOver=MouseOverState.Out;						// Clear the tooltip:			Document.tooltip=null;						// Update css:			Style.Computed.Unhover();						mouseEvent.target=this;			Document.window.Event=mouseEvent;			Run("onmouseout",mouseEvent);			if(OnMouseOut!=null){				OnMouseOut(mouseEvent);			}		}						/// <summary>Called on focused elements only (see focus()). Runs the mouse move functions.</summary>		public void OnMouseMoveEvent(UIEvent moveEvent){						if(this["onmousemove"]!=null){				Run("onmousemove",moveEvent);			}						if(OnMouseMove!=null){				OnMouseMove(moveEvent);			}					}				/// <summary>Performs a mouse over on the child elements of this element.</summary>		/// <param name="mouseEvent">The event that represents where the mouse is.</param>		/// <returns>True if any child elements had the mouse over it.</returns>		public bool RunMouseOverOnKids(UIEvent mouseEvent){			// Is the x/y co-ords on any of my kids?			bool result=false;						if(ChildNodes!=null){				for(int i=ChildNodes.Count-1;i>=0;i--){					// Backwards is important here! The one at the back is most likely the highest;					// It's only z-index that might throw this off.					if(ChildNodes[i].RunMouseOver(mouseEvent)){						result=true;					}					if(mouseEvent.cancelBubble){						return result;					}				}			}						if(HScrollbar){				if(HorizontalScrollbar.Element.RunMouseOver(mouseEvent)){					result=true;				}				if(mouseEvent.cancelBubble){					return result;					}			}						if(VScrollbar){				if(VerticalScrollbar.Element.RunMouseOver(mouseEvent)){					result=true;				}				if(mouseEvent.cancelBubble){					return result;					}			}						return result;		}				/// <summary>Performs a mouse over on this element.</summary>		/// <param name="clickEvent">The event that represents where the mouse is.</param>		/// <returns>True if this or any child has the mouse over it.</returns>		public bool RunMouseOver(UIEvent mouseEvent){			// Text elements ignore this entirely:			if(GetType()==typeof(TextElement)){				return false;			}						// Returns true if any element was clicked over.			if(Handler.IgnoreClick || Style.Computed.Display==DisplayType.None){				return false;			}						bool contains=Style.Computed.Contains(mouseEvent.clientX,mouseEvent.clientY);						// Run on kids first:			bool overKids=false;			if(contains || Style.Computed.OverflowX==OverflowType.Visible || Style.Computed.OverflowY==OverflowType.Visible){				overKids=RunMouseOverOnKids(mouseEvent);			}						if(mouseEvent.cancelBubble||Handler.IgnoreSelfClick){				// True if the element doesn't want to accept clicks on itself (e.g. body/html tags).				return overKids;			}						if(contains){				bool result=MouseOver(mouseEvent);				return (result || overKids);			}						return overKids;		}					}	}