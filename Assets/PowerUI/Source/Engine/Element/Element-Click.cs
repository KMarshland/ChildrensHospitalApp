//--------------------------------------//               PowerUI////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;using PowerUI.Css;namespace PowerUI{			public partial class Element{						/// <summary>Called by a tag handler when a click occurs.</summary>		/// <param name="clickEvent">The event that represents the click.</param>		/// <returns>True if it accepted the click.</returns>		public bool OnClickEvent(UIEvent clickEvent){			bool result=false;						if(clickEvent.heldDown){				Input.LastMouseDown.Add(this);								if(this["onmousedown"]!=null){					Run("onmousedown",clickEvent);					result=true;				}								if(OnMouseDown!=null){					OnMouseDown(clickEvent);					result=true;				}								// Apply the active style:				if(MousedOver==MouseOverState.OverConsumed){					Style.Computed.Unhover();				}								Style.Computed.SetModifier("active");							}else{				if(this["onmouseup"]!=null){					Run("onmouseup",clickEvent);					result=true;				}								if(OnMouseUp!=null){					OnMouseUp(clickEvent);					result=true;				}								if(MouseWasDown()){					if(this["onclick"]!=null){						Run("onclick",clickEvent);						result=true;					}										if(OnClick!=null){						OnClick(clickEvent);						result=true;					}									}							}			return result;		}				/// <summary>Was the mouse clicked on this element during the last mouse down?</summary>		public bool MouseWasDown(){			foreach(Element element in Input.LastMouseDown){				if(element==this){					return true;				}			}						return false;		}				/// <summary>Performs a click (mouse down or up) on this element.</summary>		/// <param name="clickEvent">The event that represents where the mouse is.</param>		/// <returns>True if this or any child accepted the click.</returns>		public bool RunClick(UIEvent clickEvent){			// Text elements ignore this entirely:			if(GetType()==typeof(TextElement)){				return false;			}						if(Handler.IgnoreClick || Style.Computed.Display==DisplayType.None){				return false;			}						bool contains=Style.Computed.Contains(clickEvent.clientX,clickEvent.clientY);						// Run on kids first:			bool kidsResult=false;			if(contains || Style.Computed.OverflowX==OverflowType.Visible || Style.Computed.OverflowY==OverflowType.Visible){				kidsResult=RunClickOnKids(clickEvent);			}						if(clickEvent.cancelBubble||Handler.IgnoreSelfClick){				// True if the element doesn't want to accept clicks on itself (e.g. body/html tags).				return kidsResult;			}						if(contains){				// Run click on this element:				bool result=GotClicked(clickEvent);				return (result || kidsResult);			}			return kidsResult;		}				/// <summary>Run a click on this element.</summary>		/// <param name="clickEvent">The event that represents the mouse location.</param>		/// <returns>True if this element accepted the click.</returns>		public bool GotClicked(UIEvent clickEvent){			clickEvent.target=this;						bool handlerClick=Handler.OnClick(clickEvent);						if(!handlerClick){				return HasBackground;			}						return true;		}				/// <summary>Attempts to run a click on the children of this element.</summary>		/// <param name="clickEvent">The click event which represents various properties of the mouse.</param>		/// <returns>True if any child element consumed this event.</returns>		public bool RunClickOnKids(UIEvent clickEvent){			// Is the x/y co-ords on any of my kids?			bool result=false;						if(ChildNodes!=null){				for(int i=ChildNodes.Count-1;i>=0;i--){					// Backwards is important here! The one at the back is most likely the highest;					// It's only z-index that might throw this off.					if(ChildNodes[i].RunClick(clickEvent)){						result=true;					}										if(clickEvent.cancelBubble || i>=ChildNodes.Count){						return result;					}				}			}						if(HScrollbar){				if(HorizontalScrollbar.Element.RunClick(clickEvent)){					result=true;				}				if(clickEvent.cancelBubble){					return result;				}			}						if(VScrollbar){				if(VerticalScrollbar.Element.RunClick(clickEvent)){					result=true;				}				if(clickEvent.cancelBubble){					return result;				}			}						return result;		}					}	}