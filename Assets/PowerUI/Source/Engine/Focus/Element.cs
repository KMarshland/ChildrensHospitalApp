//--------------------------------------//               PowerUI////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;using UnityEngine;using PowerUI.Css;using Wrench;using Nitro;namespace PowerUI{		/// <summary>	/// Provides additional Element methods for managing focus.	/// </summary>		public partial class Element:MLElement{				/// <summary>True if this element is focusable.</summary>		public bool focusable{			get{				return ( (Handler.IsFocusable || this["focusable"]!=null) && (this["disabled"]==null) );			}		}				/// <summary>Gets the nearest focusable element above this.</summary>		/// <returns>The nearest focusable element above. Null if there is none.</returns>		public Element GetFocusableAbove(){						// Has the element defined something specific?			Element target=GetFocusableOverride("up");						if(target!=null){				// Yep, it did!				return target;			}						// Distance of the nearest element (set when nearest is first set):			float nearestDistance=0f;			// The current nearest element:			Element nearest=null;			// Grab my computed style:			ComputedStyle computed=Style.Computed;			// Get hold of the iterator (so we can safely skip child elements):			DocumentElements allElements=Document.allElements;						// Grab my x position:			float myX=computed.GetMidpointX();			// Grab the midpoint of this element on Y:			float myY=computed.GetMidpointY();									// For each element in the dom that is focusable and above this..			foreach(Element element in allElements){				if(element!=this && element.IsAbove(computed) && element.focusable){					// We have an element above.										// Check if it is closer than the current result.					// If it is, it's the current result.										// Is it nearer?					float distance=element.DistanceFromFast(myX,myY);										// Next, weight the distance by it's verticalness - that's by how much above/below the element actually looks.					float verticalness=element.VerticalDistanceRatio(myX,myY);										if(verticalness<0.01f){						verticalness=0.01f;					}										distance*=verticalness;										// Is it the first we've found, or is it nearer?					if(nearest==null || distance<nearestDistance){						nearest=element;						nearestDistance=distance;					}										// Make sure we don't now iterate its kids:					allElements.SkipChildren=true;				}			}						return nearest;		}				/// <summary>Gets the nearest focusable element below this.</summary>		/// <returns>The nearest focusable element below. Null if there is none.</returns>		public Element GetFocusableBelow(){						// Has the element defined something specific?			Element target=GetFocusableOverride("down");						if(target!=null){				// Yep, it did!				return target;			}						// Distance of the nearest element (set when nearest is first set):			float nearestDistance=0f;			// The current nearest element:			Element nearest=null;			// Grab my computed style:			ComputedStyle computed=Style.Computed;			// Get hold of the iterator (so we can safely skip child elements):			DocumentElements allElements=Document.allElements;						// Grab my x position:			float myX=computed.GetMidpointX();			// Grab the midpoint of this element on Y:			float myY=computed.GetMidpointY();									// For each element in the dom that is focusable and below this..			foreach(Element element in allElements){				if(element!=this && element.IsBelow(computed) && element.focusable){					// We have an element below.										// Check if it is closer than the current result.					// If it is, it's the current result.										// Is it nearer?					float distance=element.DistanceFromFast(myX,myY);										// Next, weight the distance by it's verticalness - that's by how much above/below the element actually looks.					float verticalness=element.VerticalDistanceRatio(myX,myY);										if(verticalness<0.01f){						verticalness=0.01f;					}										distance*=verticalness;										// Is it the first we've found, or is it nearer?					if(nearest==null || distance<nearestDistance){						nearest=element;						nearestDistance=distance;					}										// Make sure we don't now iterate its kids:					allElements.SkipChildren=true;				}			}						return nearest;		}				/// <summary>Gets the nearest focusable element left of this.</summary>		/// <returns>The nearest focusable element to the left. Null if there is none.</returns>		public Element GetFocusableLeft(){						// Has the element defined something specific?			Element target=GetFocusableOverride("left");						if(target!=null){				// Yep, it did!				return target;			}						// Distance of the nearest element (set when nearest is first set):			float nearestDistance=0f;			// The current nearest element:			Element nearest=null;			// Grab my computed style:			ComputedStyle computed=Style.Computed;			// Get hold of the iterator (so we can safely skip child elements):			DocumentElements allElements=Document.allElements;						// Grab my x position:			float myX=computed.GetMidpointX();			// Grab the midpoint of this element on Y:			float myY=computed.GetMidpointY();									// For each element in the dom that is focusable and to the left of this..			foreach(Element element in allElements){				if(element!=this && element.IsLeftOf(computed) && element.focusable){					// We have an element to our left.										// Check if it is closer than the current result.					// If it is, it's the current result.										// Is it nearer?					float distance=element.DistanceFromFast(myX,myY);										// Next, weight the distance by it's horizontalness - that's how much to the right/left the element actually looks.					float horizontalness=element.HorizontalDistanceRatio(myX,myY);										if(horizontalness<0.01f){						horizontalness=0.01f;					}										distance*=horizontalness;										// Is it the first we've found, or is it nearer?					if(nearest==null || distance<nearestDistance){						nearest=element;						nearestDistance=distance;					}										// Make sure we don't now iterate its kids:					allElements.SkipChildren=true;				}			}						return nearest;		}				/// <summary>Gets the nearest focusable element right of this.</summary>		/// <returns>The nearest focusable element to the right. Null if there is none.</returns>		public Element GetFocusableRight(){						// Has the element defined something specific?			Element target=GetFocusableOverride("right");						if(target!=null){				// Yep, it did!				return target;			}						// Distance of the nearest element (set when nearest is first set):			float nearestDistance=0f;			// The current nearest element:			Element nearest=null;			// Grab my computed style:			ComputedStyle computed=Style.Computed;			// Get hold of the iterator (so we can safely skip child elements):			DocumentElements allElements=Document.allElements;						// Grab my x position:			float myX=computed.GetMidpointX();			// Grab the midpoint of this element on Y:			float myY=computed.GetMidpointY();									// For each element in the dom that is focusable and to the right of this..			foreach(Element element in allElements){				if(element!=this && element.IsRightOf(computed) && element.focusable){					// We have an element to our right.										// Check if it is closer than the current result.					// If it is, it's the current result.										// Is it nearer?					float distance=element.DistanceFromFast(myX,myY);										// Next, weight the distance by it's horizontalness - that's how much to the right/left the element actually looks.					float horizontalness=element.HorizontalDistanceRatio(myX,myY);										if(horizontalness<0.01f){						horizontalness=0.01f;					}										distance*=horizontalness;										// Is it the first we've found, or is it nearer?					if(nearest==null || distance<nearestDistance){						nearest=element;						nearestDistance=distance;					}										// Make sure we don't now iterate its kids:					allElements.SkipChildren=true;				}			}						return nearest;		}				/// <summary>Checks if this element defines a specific focusable element by id in the given direction.		/// E.g. it's defined focus-right, focus-left, focus-up, focus-down.</summary>		/// <param name="direction">The direction to look for an override in.</param>		/// <returns>The overriding element, if found. Null otherwise.</returns>		private Element GetFocusableOverride(string direction){			string definedTarget=this["focus-"+direction];						if(definedTarget!=null){				Element result=Document.getElementById(definedTarget);								if(result==null){					Wrench.Log.Add("Warning: Element with id '"+definedTarget+"' was not found.");				}else{					return result;				}			}						return null;		}				/// <summary>Used for tab focus. Gets the next available focusable element.</summary>		/// <returns>The next available focusable element. Null if there is none.</returns>		public Element GetFocusedNext(){			return null;		}				/// <summary>Finds out the distance in pixels on the x and y axis the given point is away from this elements midpoint.</summary>		/// <param name="x">The x coordinate to check from.</param>		/// <param name="y">The y coordinate to check from.</param>		/// <returns>The distance on each axis from the given point as a vector.</returns>		public Vector2 AxisDistanceFrom(float x,float y){			ComputedStyle computed=Style.Computed;						x-=computed.GetMidpointX();			y-=computed.GetMidpointY();						if(x<0f){				x=-x;			}						if(y<0f){				y=-y;			}						return new Vector2(x,y);		}				/// <summary>Finds the distance on both axis of the given point from this elements midpoint. Then, it divides 		/// the y result by the x result giving a ratio of 'horizontalness' of the distance. This is used by focus graphs, as it can		/// be used to perceive how leftward or how rightward an element is.</summary>		private float HorizontalDistanceRatio(float x,float y){			ComputedStyle computed=Style.Computed;						// Find the distance along both axis:			x-=computed.GetMidpointX();			y-=computed.GetMidpointY();						if(x<0f){				x=-x;			}						if(y<0f){				y=-y;			}						if(x==0f){				// Vertical line - it's not horizontal at all!				return float.MaxValue;			}						return y/x;		}				/// <summary>Finds the distance on both axis of the given point from this elements midpoint. Then, it divides 		/// the x result by the y result giving a ratio of 'verticalness' of the distance. This is used by focus graphs, as it can		/// be used to perceive how upward or how downward an element is.</summary>		private float VerticalDistanceRatio(float x,float y){			ComputedStyle computed=Style.Computed;						// Find the distance along both axis:			x-=computed.GetMidpointX();			y-=computed.GetMidpointY();						if(x<0f){				x=-x;			}						if(y<0f){				y=-y;			}						if(y==0f){				// Horizontal line - it's not vertical at all!				return float.MaxValue;			}						return x/y;		}				/// <summary>Gets a relative 2D distance of this elements midpoint from the given point.		/// The value returned is a fast distance used for comparison only. Use DistanceFrom for the correct distance.</summary>		/// <param name="x">The x coordinate to check from.</param>		/// <param name="y">The y coordinate to check from.</param>		public float DistanceFromFast(float x,float y){			ComputedStyle computed=Style.Computed;						x-=computed.GetMidpointX();			y-=computed.GetMidpointY();						return ( (x*x) + (y*y) );		}				/// <summary>Gets the 2D distance of this elements midpoint from the given point.</summary>		/// <param name="x">The x coordinate to check from.</param>		/// <param name="y">The y coordinate to check from.</param>		public float DistanceFrom(float x,float y){			return Mathf.Sqrt(DistanceFromFast(x,y));		}				/// <summary>Checks if this element is to the left of the given style.</summary>		/// <returns>True if this element is to the left of the given style.</returns>		public bool IsLeftOf(ComputedStyle computed){			// Check if my left edge is before (but not equal to) the given left edge.			return (Style.Computed.OffsetLeft < computed.OffsetLeft);		}				/// <summary>Checks if this element is to the right of the given style.</summary>		/// <returns>True if this element is to the right of the given style.</returns>		public bool IsRightOf(ComputedStyle computed){			// Check if my right edge is after (but not equal to) the given right edge.			return (Style.Computed.OffsetLeft + Style.Computed.PixelWidth) > (computed.OffsetLeft + computed.PixelWidth);		}				/// <summary>Checks if this element is above the given style.</summary>		/// <returns>True if this element is above the given style.</returns>		public bool IsAbove(ComputedStyle computed){			// Check if my top edge is less than (but not equal to) the given top edge.			return (Style.Computed.OffsetTop < computed.OffsetTop);		}				/// <summary>Checks if this element is below the given style.</summary>		/// <returns>True if this element is below the given style.</returns>		public bool IsBelow(ComputedStyle computed){			// Check if my bottom edge is greater than (but not equal to) the given bottom edge.			return (Style.Computed.OffsetTop + Style.Computed.PixelHeight) > (computed.OffsetTop + computed.PixelHeight);		}			}}