//--------------------------------------//               PowerUI////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;using System.Collections;using System.Collections.Generic;using Wrench;namespace PowerUI.Css{		/// <summary>	/// Holds a set of selector styles. A selector is something like .name or #name.	/// </summary>		public class StyleSheet{				/// <summary>The html document that this sheet belongs to.</summary>		public Document Document;		/// <summary>A lookup of the selectors that have modified forms. E.g. input:hover will add the selector to a key of "input".</summary>		public Dictionary<string,List<Css.SelectorStyle>> ModifiedSelectors;		/// <summary>A lookup of the selectors contained in this sheet to their parsed styles.</summary>		public Dictionary<string,Css.SelectorStyle> Selectors=new Dictionary<string,Css.SelectorStyle>();						/// <summary>Creates an empty stylesheet that belongs to the given document.</summary>		/// <param name="document">The html document that this sheet belongs to.</param>		public StyleSheet(Document document){			Document=document;		}				/// <summary>Creates a new stylesheet that belongs to the given document. Sets the given css text to it.</summary>		/// <param name="document">The html document that this sheet belongs to.</param>		/// <param name="text">Some css text structured into selectors and their properties that should be set into this stylesheet.</param>		public StyleSheet(Document document,string text):this(document){			ParseCss(text);		}				/// <summary>Attempts to get a style from this sheet by selector.</summary>		/// <param name="selector">The selector to lookup.</param>		/// <returns>A style for the selector if its found; null otherwise.</returns>		public Css.SelectorStyle GetStyleBySelector(string selector){			Css.SelectorStyle result;			Selectors.TryGetValue(selector,out result);			return result;		}				/// <summary>Adds a modified form of the given selector. E.g. style might be the input:hover style.		/// That style is a modified form of the "input" selector.</summary>		/// <param name="selector">The modified selector, e.g. "input".</param>		/// <param name="style">The style.</param>		public void AddModified(string selector,Css.SelectorStyle style){						if(ModifiedSelectors==null){				ModifiedSelectors=new Dictionary<string,List<Css.SelectorStyle>>();			}						// Grab any existing list:			List<Css.SelectorStyle> allModifiers=GetModifiers(selector);						// Does the list exist?			if(allModifiers==null){				allModifiers=new List<Css.SelectorStyle>();				ModifiedSelectors[selector]=allModifiers;			}						// Add the new style in:			allModifiers.Add(style);		}				/// <summary>Gets all the modified forms of the given selector.		/// E.g. selector could be "input", in which case there may be ":hover",":focus" etc.</summary>		/// <param name="selector">The selector to search for.</param>		/// <returns>The set of modified styles, if found. Null otherwise.</returns>		public List<Css.SelectorStyle> GetModifiers(string selector){			if(ModifiedSelectors==null){				return null;			}						// Try and pull them from the set:			List<Css.SelectorStyle> modifiedForms=null;			ModifiedSelectors.TryGetValue(selector,out modifiedForms);			return modifiedForms;		}				/// <summary>Attempts to read a block comment from the given lexer.</summary>		/// <param name="lexer">The lexer to read it from.</param>		/// <param name="currentCharacter">The next character in the lexer.</param>		/// <returns>True if a block comment was read.</returns>		private bool TryReadBlockComment(MLLexer lexer,char currentCharacter){			if(currentCharacter=='/'&&lexer.Peek(1)=='*'){				// CSS block comment.				lexer.Read();				lexer.Read();				currentCharacter=lexer.Peek();								while(currentCharacter!=StringReader.NULL){					if(currentCharacter=='*'&&lexer.Peek(1)=='/'){						//all done!						lexer.Read();						lexer.Read();						break;					}					lexer.Read();					currentCharacter=lexer.Peek();				}								return true;			}						return false;		}				/// <summary>Creates a new selector block for the given selector/modifier combo.</summary>		public SelectorStyle StartSelector(string selector,string modifier){						string fullSelector=selector;			bool modified=false;						if(!string.IsNullOrEmpty(modifier)){				// Make it lowercase:				modifier=modifier.ToLower();								// Append it to the selector:				fullSelector+=":"+modifier;				modified=true;			}						// Generate a style object for this selector if it doesn't already have one:			SelectorStyle style=null;						if(fullSelector=="@font-face"){								// Special case for the font-face selector style.				// - Load the font and add it to the document's renderer,				style=new SelectorStyle(this,selector,modifier);								return style;							}						if(!Selectors.TryGetValue(fullSelector,out style)){				Selectors[fullSelector]=style=new SelectorStyle(this,selector,modifier);								if(modified){										// Add it as a modified form:					AddModified(selector,style);									}								// Does a default selector exist?				if(Document.DefaultStyleSheet!=null && Document.DefaultStyleSheet!=this){					SelectorStyle defaultStyle=Document.DefaultStyleSheet.GetStyleBySelector(fullSelector);										if(defaultStyle!=null){						// This tag has a default style - we must copy the content from it into the new overriding tag.						defaultStyle.CopyTo(style,false);					}				}								// Does a * selector exist? Only apply if selector is not html and a tag. Note that this must be applied last.				// Also note that it's not applied to modified styles as they are applied additively.				if(!modified && Document.DefaultStyleSheet!=null && selector!="html" && selector!="*" && style.SelectorType==Css.SelectorType.Tag){					SelectorStyle defaultStyle=Document.DefaultStyleSheet.GetStyleBySelector("*");										if(defaultStyle!=null){						// Got a * style - Copy the content from it into the new overriding tag.						defaultStyle.CopyTo(style,false);					}				}							}						return style;					}				/// <summary>Keeps reading selectors and their properties until a &gt; or the end of the css is reached.</summary>		/// <param name="css">The css text to parse.</param>		public void ParseCss(string css){			MLLexer lexer=new MLLexer(css);			char currentCharacter=lexer.Peek();			while(currentCharacter!='<'&&currentCharacter!=StringReader.NULL){								if(TryReadBlockComment(lexer,currentCharacter)){					currentCharacter=lexer.Peek();					continue;				}								// Read a selector:				string selector="";				string modifier="";				bool inModifier=false;				List<Selector> additionalSelectors=null;								while(currentCharacter!='{'&&currentCharacter!='<'&&currentCharacter!=StringReader.NULL){					// Read it off:					lexer.Read();										if(currentCharacter==' '){						// Skip spaces here.					}else if(currentCharacter==','){						// We have a series of selectors.												if(selector!=""){							// Store the current one in the additional list:							if(additionalSelectors==null){								additionalSelectors=new List<Selector>(1);							}														additionalSelectors.Add(new Selector(this,selector,modifier));														// Clear the current one:							selector="";							modifier="";							inModifier=false;						}											}else if(currentCharacter==':'){						if(inModifier){							// Already in the modifier - they've been daisy chained.							// So, the modifier we've read so far is actually part of the selector:							selector+=":"+modifier.ToLower();							modifier="";						}												inModifier=true;					}else if(inModifier){						// Add it to the modifier:						modifier+=currentCharacter;					}else{						// Add it to the selector:						selector+=currentCharacter;					}										// Peek the next one:					currentCharacter=lexer.Peek();				}							if(currentCharacter=='{'){					// Read it off:					lexer.Read();				}else{					// It must have been a < or null. Halt.					break;				}								// Start the style block:				SelectorStyle style=StartSelector(selector,modifier);								// Read the properties inside a selectors block. Literal reading after : until ;				bool readPropertyName=true;				string propertyName="";				string propertyValue="";								currentCharacter=lexer.Peek();								while(currentCharacter!='}'&&currentCharacter!='<'&&currentCharacter!=StringReader.NULL){										if(readPropertyName){												if(TryReadBlockComment(lexer,currentCharacter)){							currentCharacter=lexer.Peek();							continue;						}												if(currentCharacter==':'){							// Bump into literal mode.							lexer.Literal=true;							readPropertyName=false;						}else{							propertyName+=currentCharacter;						}											}else{												if(currentCharacter==';'){							// Pop out of literal mode, and go back to property names.							readPropertyName=true;							lexer.Literal=false;														// And push our new propertyName/propertyValue set:							style.SetDirect(propertyName,propertyValue);														if(additionalSelectors!=null){								// We have more,than,one selector.																// Set to them too:								for(int i=additionalSelectors.Count-1;i>=0;i--){									additionalSelectors[i].Style.SetDirect(propertyName,propertyValue);								}															}														propertyName="";							propertyValue="";						}else{							propertyValue+=currentCharacter;						}											}										// Read it off:					lexer.Read();					// And take a look at what's next:					currentCharacter=lexer.Peek();				}								// Let the style know it's done loading:				style.OnLoaded();								// 'Bake' the new styles into their modified forms, if any have been loaded yet.				style.BakeToModifiers();								if(additionalSelectors!=null){					// We have more,than,one selector.										// Start their blocks too:					for(int i=additionalSelectors.Count-1;i>=0;i--){						additionalSelectors[i].Style.BakeToModifiers();					}									}								if(currentCharacter=='}'){					// Read it off:					lexer.Read();					// And setup the next character:					currentCharacter=lexer.Peek();				}else{					// Halt - it was a null or <.					break;				}								// Ensure we're out of literal mode:				lexer.Literal=false;			}					}			}	}