//--------------------------------------//               PowerUI////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;using UnityEngine;using Blaze;namespace PowerUI.Css{		/// <summary>	/// Base class for any property of an element that can be visually displayed, e.g. backgrounds and borders.	/// </summary>		public class DisplayableProperty{				/// <summary>True if this is currently visible on screen.</summary>		public bool Visible;		/// <summary>True if this property has changed its appearance.</summary>		public bool Changed;		/// <summary>True if this property is isolated and has a seperate mesh and material from everything else.</summary>		public bool Isolated;		/// <summary>The number of mesh blocks that this property has allocated.</summary>		public int BlockCount;		/// <summary>The parent element that this is a property of.</summary>		public Element Element;		/// <summary>The first mesh block that this property has allocated. This is the head of a linked list.</summary>		public MeshBlock FirstBlock;		/// <summary>Only applies to Isolated properties. Set to true when this property has allocated a UIBatch on the current layout.</summary>		public bool GotBatchAlready;						/// <summary>Creates a new displayable property for the given element.</summary>		public DisplayableProperty(Element element){			Element=element;		}				/// <summary>Call this when the visibility of this property as a whole changes.</summary>		public void SetVisibility(bool visible){						// Fire visibility events now.			if(visible){								if(NowOnScreen()){					// Otherwise it rejected it. That can happen when an image hasn't loaded yet (nothing to see anyway).					Visible=true;				}							}else{				Visible=false;				NowOffScreen();			}					}				/// <summary>Called when this element goes on screen.</summary>		protected virtual bool NowOnScreen(){			return true;		}				/// <summary>Called when this element goes off screen (or is removed from the DOM).</summary>		protected virtual void NowOffScreen(){}				/// <summary>Sets the overlay colour from the elements colour overlay property.</summary>		public void SetOverlayColour(){			SetOverlayColour(Element.Style.Computed.ColorOverlay);		}				/// <summary>Call this when any colour of this property has changed.</summary>		public void ColourChanged(){			SetOverlayColour(Element.Style.Computed.ColorOverlay);			Changed=true;		}				/// <summary>Called when the isolation batch for this property gets removed.</summary>		public virtual void OnBatchDestroy(){		}				/// <summary>Called to apply the given colour overlay to this property.</summary>		/// <param name="colour">The colour overlay to apply.</param>		public virtual void SetOverlayColour(Color colour){}				/// <summary>Called when a named css property changes.</summary>		/// <param name="property">The css property that changed.</param>		/// <param name="newValue">The properties new value. It may also be null.</param>		public void Change(string property,Value newValue){			Changed=true;			OnChange(property,newValue);		}				/// <summary>Called when a named css property changes.</summary>		/// <param name="property">The css property that changed.</param>		/// <param name="newValue">The properties new value. It may also be null.</param>		protected virtual void OnChange(string property,Value newValue){}				/// <summary>Clears all mesh blocks that this property has allocated.</summary>		public void ClearBlocks(){			BlockCount=0;			FirstBlock=null;			GotBatchAlready=false;		}				public void WentOffScreen(){			ClearBlocks();						if(Visible){				SetVisibility(false);			}		}				/// <summary>Maps the given pixel location to a world location.</summary>		/// <param name="x">The x location of the pixel from the left of the screen.</param>		/// <param name="y">The y location of the pixel from the top of the screen.</param>		/// <param name="z">The depth of the pixel (already in world units).</param>		/// <returns>A point in 3D that can be used as a vertex.</returns>		public Vector3 MapPX(float x,float y,float z){			return Element.Document.Renderer.PixelToWorldUnit(x,y,z);		}				/// <summary>Make this property visible by forcing it to redraw.</summary>		public void Render(){			ClearBlocks();			Layout();		}				/// <summary>Requests for a paint event to occur. Note that paint events are more efficient than a layout		/// as they only refresh the mesh colours and uvs rather than the whole mesh.</summary>		public void RequestPaint(){						if(FirstBlock!=null){								Element.Document.Renderer.RequestPaint(Element.Style);							}else{							Element.Document.Renderer.RequestLayout();							}					}				/// <summary>Requests for a layout event to occur. Note that paint events are more efficient than a layout		/// as they only refresh the mesh colours and uvs rather than the whole mesh.</summary>		public void RequestLayout(){			Element.Document.Renderer.RequestLayout();		}				/// <summary>Called when a paint event occurs. Paint events don't relocate the whole UI so are quick and efficient.</summary>		public virtual void Paint(){		}				/// <summary>Called when a layout event occurs. Layout events relocate the whole UI so should be used less frequently than a paint event.</summary>		protected virtual void Layout(){			//Add, Remove or change any blocks.		}				/// <summary>Allocates a new mesh block for this property to use.		/// Mesh blocks are the core of how PowerUI displays content.</summary>		public MeshBlock Add(){			MeshBlock block=Element.Document.Renderer.CurrentBatch.Allocate();						BlockCount++;			block.LocalBlockAfter=FirstBlock;			FirstBlock=block;						return block;		}				/// <summary>Checks if this property can be repainted.</summary>		/// <returns>True if this property has blocks allocated as they can be repainted; false otherwise.</returns>		public bool Paintable{			get{				return (FirstBlock!=null);			}		}				/// <summary>Transforms all the blocks that this property has allocated. Note that transformations are a post process.</summary>		/// <param name="topTransform">The transform that should be applied to this property.</param>		public void Transform(Transformation topTransform){			MeshBlock block=FirstBlock;						while(block!=null){				block.Transform=topTransform;				block=block.LocalBlockAfter;			}					}				/// <summary>Applies any transforms (rotate,scale etc) now. Note that tranforms are post-processes		/// so they are very fast and mostly done by paint events.</summary>		public void ApplyTransform(){			MeshBlock block=FirstBlock;						while(block!=null){				if(block.Transform!=null){					block.Layout();				}				block=block.LocalBlockAfter;			}					}				/// <summary> Isolates this property from the rest of the UI such that it can have a custom mesh/shader/texture etc.</summary>		public void Isolate(){			Isolated=true;		}				/// <summary>Reverses <see cref="PowerUI.Css.DisplayableProperty.Isolate"/> by		/// re-including this property in the main UI batch.</summary>		public void Include(){			Isolated=false;		}				/// <summary>Checks if this is an isolated property - that's one which is seperate and takes its own drawcall.</summary>		/// <returns>True if it is isolated; false otherwise.</returns>		public bool IsIsolated(){			return Isolated;		}				public void SetupBatch(TextureAtlas graphics,TextureAtlas font){						// Setup batch:			Element.Document.Renderer.SetupBatch(this,graphics,font);					}				public AtlasLocation RequireImage(AtlasEntity image){						// Get the image from the global atlas stack.			AtlasLocation location=AtlasStacks.Graphics.RequireImage(image);						if(location==null){				// It's separate from the atlas. Too big to fit/ not worth being on an atlas.				Isolate();			}else{				location.UsageCount++;				Include();			}						return location;					}			}	}