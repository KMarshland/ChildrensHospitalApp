//--------------------------------------//               PowerUI////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;using UnityEngine;namespace PowerUI.Css{		/// <summary>	/// Base class for any property of an element that can be visually displayed, e.g. backgrounds and borders.	/// </summary>		public class DisplayableProperty{				/// <summary>True if this property has changed its appearance.</summary>		public bool Changed;		/// <summary>True if this property is isolated and has a seperate mesh and material from everything else.</summary>		public bool Isolated;		/// <summary>The number of mesh blocks that this property has allocated.</summary>		public int BlockCount;		/// <summary>The parent element that this is a property of.</summary>		public Element Element;		/// <summary>The first mesh block that this property has allocated. This is the head of a linked list.</summary>		public MeshBlock FirstBlock;		/// <summary>Only applies to Isolated properties. Set to true when this property has allocated a UIBatch on the current layout.</summary>		public bool GotBatchAlready;						/// <summary>Creates a new displayable property for the given element.</summary>		public DisplayableProperty(Element element){			Element=element;		}				/// <summary>Sets the overlay colour from the elements colour overlay property.</summary>		public void SetOverlayColour(){			SetOverlayColour(Element.Style.Computed.ColorOverlay);		}				/// <summary>Call this when any colour of this property has changed.</summary>		public void ColourChanged(){			SetOverlayColour(Element.Style.Computed.ColorOverlay);			Changed=true;		}				/// <summary>Called when the isolation batch for this property gets removed.</summary>		public virtual void OnBatchDestroy(){		}				/// <summary>Called to apply the given colour overlay to this property.</summary>		/// <param name="colour">The colour overlay to apply.</param>		public virtual void SetOverlayColour(Color colour){}				/// <summary>Called when a named css property changes.</summary>		/// <param name="property">The css property that changed.</param>		/// <param name="newValue">The properties new value. It may also be null.</param>		public void Change(string property,Value newValue){			Changed=true;			OnChange(property,newValue);		}				/// <summary>Called when a named css property changes.</summary>		/// <param name="property">The css property that changed.</param>		/// <param name="newValue">The properties new value. It may also be null.</param>		protected virtual void OnChange(string property,Value newValue){}				/// <summary>Clears all mesh blocks that this property has allocated.</summary>		public void ClearBlocks(){			BlockCount=0;			FirstBlock=null;			GotBatchAlready=false;		}				/// <summary>Maps the given pixel location to a world location.</summary>		/// <param name="x">The x location of the pixel from the left of the screen.</param>		/// <param name="y">The y location of the pixel from the top of the screen.</param>		/// <param name="z">The depth of the pixel (already in world units).</param>		/// <returns>A point in 3D that can be used as a vertex.</returns>		public Vector3 MapPX(float x,float y,float z){			return Element.Document.Renderer.PixelToWorldUnit(x,y,z);		}				/// <summary>Make this property visible by forcing it to redraw.</summary>		public void Render(){			ClearBlocks();			Layout();		}				/// <summary>Adds the given block to this properties set of allocated mesh blocks.</summary>		/// <param name="block">The mesh block to add.</param>		public void AddBlock(MeshBlock block){			BlockCount++;			block.LocalBlockAfter=FirstBlock;			FirstBlock=block;		}				/// <summary>Requests for a paint event to occur. Note that paint events are more efficient than a layout		/// as they only refresh the mesh colours and uvs rather than the whole mesh.</summary>		public void RequestPaint(){			if(IsPaintable()){				Element.Document.Renderer.RequestPaint(Element.Style);			}else{				RequestLayout();			}		}				/// <summary>Requests for a layout event to occur. Note that paint events are more efficient than a layout		/// as they only refresh the mesh colours and uvs rather than the whole mesh.</summary>		public void RequestLayout(){			Element.Document.Renderer.RequestLayout();		}				/// <summary>Called when a paint event occurs. Paint events don't relocate the whole UI so are quick and efficient.</summary>		public virtual void Paint(){		}				/// <summary>Called when a layout event occurs. Layout events relocate the whole UI so should be used less frequently than a paint event.</summary>		protected virtual void Layout(){			//Add, Remove or change any blocks.		}				/// <summary>Sets the current font texture. Note that this only works on batches using the 		/// default UI shader.</summary>		/// <param name="texture">The font texture to use.</param>		public void SetFontTexture(Texture2D texture){			Element.Document.Renderer.SetupBatch(this,texture);		}				/// <summary>Allocates a new mesh block for this property to use.		/// Mesh blocks are the core of how PowerUI displays content.</summary>		public MeshBlock Add(){			Element.Document.Renderer.SetupBatch(this);			MeshBlock result=Element.Document.Renderer.CurrentBatch.Allocate();			AddBlock(result);			return result;		}				/// <summary>Checks if this property can be repainted.</summary>		/// <returns>True if this property has blocks allocated as they can be repainted; false otherwise.</returns>		public bool IsPaintable(){			return (FirstBlock!=null);		}				/// <summary>Transforms all the blocks that this property has allocated. Note that transformations are a post process.</summary>		/// <param name="topTransform">The transform that should be applied to this property.</param>		public void Transform(Transformation topTransform){			MeshBlock block=FirstBlock;						while(block!=null){				block.Transform=topTransform;				block=block.LocalBlockAfter;			}					}				/// <summary>Applies any transforms (rotate,scale etc) now. Note that tranforms are post-processes		/// so they are very fast and mostly done by paint events.</summary>		public void ApplyTransform(){			MeshBlock block=FirstBlock;						while(block!=null){				if(block.Transform!=null){					block.Layout();				}				block=block.LocalBlockAfter;			}					}				/// <summary> Isolates this property from the rest of the UI such that it can have a custom mesh/shader/texture etc.</summary>		public void Isolate(){			Isolated=true;		}				/// <summary>Reverses <see cref="PowerUI.Css.DisplayableProperty.Isolate"/> by		/// re-including this property in the main UI batch.</summary>		public void Include(){			Isolated=false;		}				/// <summary>Checks if this is an isolated property - that's one which is seperate and takes its own drawcall.</summary>		/// <returns>True if it is isolated; false otherwise.</returns>		public bool IsIsolated(){			return Isolated;		}				/// <summary>Adds the given texture to the texture atlas in use by this properties UI batch.</summary>		/// <param name="image">The image to add to the atlas.</param>		/// <returns>The location on the atlas of the image. Note that if the atlas has been exhausted, this may be null.</returns>		public AtlasLocation AddTexture(Texture2D image){			if(image==null){				return null;			}			Renderman renderer=Element.Document.Renderer;			renderer.CreateAtlas();			renderer.SetupBatch(this);			return renderer.CurrentBatch.AddTexture(image);		}			}	}