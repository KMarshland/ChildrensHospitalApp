//--------------------------------------//               PowerUI////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;using UnityEngine;using System.Collections;using System.Collections.Generic;namespace PowerUI.Css{	/// <summary>	/// The computed style of a html element.	/// This holds exactly where it should go and how it should look.	/// </summary>	public partial class ComputedStyle:Style{				/// <summary>Should this element be clipped at all?</summary>		public bool Clip=true;		/// <summary>The depth of this element.</summary>		public float ZIndex;		/// <summary>The depth of this element if it has defined a fixed z-index value.</summary>		public float FixedZIndex;		/// <summary>The global offset from the top edge. Computed in secondary layout pass.</summary>		public int OffsetTop;		/// <summary>The global offset from the left edge. Computed in secondary layout pass.</summary>		public int OffsetLeft;		/// <summary>The total width in pixels of this element.</summary>		public int PixelWidth;		/// <summary>The total height in pixels of this element.</summary>		public int PixelHeight;		/// <summary>The width of this element excluding any padding/border or margins.</summary>		public int InnerWidth;		/// <summary>The height of this element excluding any padding/border or margins.</summary>		public int InnerHeight;		/// <summary>True if depth is fixed for this element with e.g. z-index:10.</summary>		public bool FixedDepth;		/// <summary>True if width is fixed for this element with e.g. width:200px.</summary>		public bool FixedWidth;		/// <summary>True if height is fixed for this element with e.g. height:100px.</summary>		public bool FixedHeight;		/// <summary>The local offset of this element relative to it's parents top edge. Computed in primary layout pass.</summary>		public int ParentOffsetTop;		/// <summary>The local offset of this element relative to it's parents left edge. Computed in primary layout pass.</summary>		public int ParentOffsetLeft;				/// <summary>The width of content in this element.</summary>		public int ContentWidth;		/// <summary>The height of the content in this element.</summary>		public int ContentHeight;		/// <summary>The width of the border at the top in pixels.</summary>		public int BorderTop;		/// <summary>The width of the border on the left in pixels.</summary>		public int BorderLeft;		/// <summary>Defines how this element should be transformed. Transforms are a post-process; They are applied after everything else.</summary>		public Transformation Transform;		/// <summary>A colour that is applied over the top of this element.</summary>		public Color ColorOverlay=Color.white;				/// <summary>The width of this element including it's padding.</summary>		public int PaddedWidth;		/// <summary>The height of this element including it's padding.</summary>		public int PaddedHeight;				/// <summary>The amount of pixels the content of this element is scrolled vertically.</summary>		public int ScrollTop;		/// <summary>The amount of pixels the content of this element is scrolled horizontally.</summary>		public int ScrollLeft;				/// <summary>The content offset from the top for this element caused by padding, margin and the border in pixels.</summary>		public int StyleOffsetTop;		/// <summary>The content offset from the left for this element caused by padding, margin and the border in pixels.</summary>		public int StyleOffsetLeft;				/// <summary>The size of the margin on the top of this element in pixels.</summary>		public int MarginTop;		/// <summary>The size of the margin on the left of this element in pixels.</summary>		public int MarginLeft;		/// <summary>The size of the margin on the right of this element in pixels.</summary>		public int MarginRight;		/// <summary>The size of the margin on the bottom of this element in pixels.</summary>		public int MarginBottom;				/// <summary>The amount of padding on the top of this element in pixels.</summary>		public int PaddingTop;		/// <summary>The amount of padding on the left of this element in pixels.</summary>		public int PaddingLeft;		/// <summary>The amount of padding on the right of this element in pixels.</summary>		public int PaddingRight;		/// <summary>The amount of padding on the bottom of this element in pixels.</summary>		public int PaddingBottom;		/// <summary>True if the elements left/right margins are auto.</summary>		public bool AutoMarginX;		/// <summary>True if the elements top/bottom margins are auto.</summary>		public bool AutoMarginY;				/// <summary>The position of the baseline in pixels.</summary>		public int Baseline;				/// <summary>The value of the top: css property.</summary>		public int PositionTop;		/// <summary>The value of the left: css property.</summary>		public int PositionLeft;		/// <summary>The value of the right: css property.</summary>		public int PositionRight;		/// <summary>The value of the bottom: css property.</summary>		public int PositionBottom;		/// <summary>True if PositionRight active.</summary>		public bool RightPositioned;		/// <summary>True if PositionBottom active.</summary>		public bool BottomPositioned;		/// <summary>When being rendered, a linked list of computed styles being 'packed' into a parent element is built up.		/// NextPacked is the one that was packed after this element.</summary>		public ComputedStyle NextPacked;		/// <summary>When being rendered, a linked list of computed styles on this line is built up. This is the next one on this line.</summary>		public ComputedStyle NextOnLine;		/// <summary>Defines the display of this element.</summary>		public DisplayType Display=DisplayType.Inline;		/// <summary>Defines the position of this element.</summary>		public PositionType Position=PositionType.Relative;		/// <summary>Defines if the content of this element should wrap automatically or not.</summary>		public WhiteSpaceType WhiteSpace=WhiteSpaceType.Normal;		/// <summary>Defines the visibility of this element.</summary>		public VisibilityType Visibility=VisibilityType.Visible;		/// <summary>Defines how content within this element should be aligned vertically.</summary>		public VerticalAlignType VerticalAlign=VerticalAlignType.Top;		/// <summary>Defines how content within this element should be aligned horizontally.</summary>		public HorizontalAlignType HorizontalAlign=HorizontalAlignType.Auto;		/// <summary>Defines how the last line of content within this element should be aligned horizontally.</summary>		public HorizontalAlignType HorizontalAlignLast=HorizontalAlignType.Auto;		/// <summary>This handles rendering the border around this element, if any.</summary>		public BorderProperty Border;		/// <summary>This handles rendering a tiled, clipped, offset background image for this element.</summary>		public BackgroundImage BGImage;		/// <summary>This handles rendering a solid background colour for this element.</summary>		public BackgroundColour BGColour;		/// <summary>This handles rendering text contained by this element.</summary>		public TextRenderingProperty Text;		/// <summary>The full height of this element. May be depreciated; see <see cref="PowerUI.ComputedStyle.PixelHeight"/>.</summary>		public int FullHeight;		/// <summary>The full width of this element. May be depreciated; see <see cref="PowerUI.ComputedStyle.PixelWidth"/>.</summary>		public int FullWidth;		/// <summary>The ID css selector for this element if any. It's the value within the id="" attribute with a "#" at the start.</summary>		public string IDSelector;		/// <summary>The tag css selector for this element. This is always the elements tag, e.g. "div".</summary>		public string TagSelector;		/// <summary>The class css selector for this element if any. It's the value within the class="" attribute with a "." at the start. If there are more than one, this is the last one.</summary>		public string ClassSelector;		/// <summary>The set of additional class selectors (since there can be more than one). Each entry has a "." at the start.</summary>		public string[] ExtraClassSelectors;		/// <summary>The maximum width of the content in pixels.</summary>		public int MaximumWidth=int.MaxValue;		/// <summary>The maximum height of the content in pixels.</summary>		public int MaximumHeight=int.MaxValue;		/// <summary>The minimum width of the content in pixels.</summary>		public int MinimumWidth=int.MinValue;		/// <summary>The minimum height of the content in pixels.</summary>		public int MinimumHeight=int.MinValue;		/// <summary>Defines how horizontally overflowing content is treated. Visible by default.		/// Only applicable to block/inline-block elements.</summary>		public OverflowType OverflowX=OverflowType.Visible;		/// <summary>Defines how vertically overflowing content is treated. Visible by default.		/// Only applicable to block/inline-block elements.</summary>		public OverflowType OverflowY=OverflowType.Visible;		/// <summary>The direction of rendering. This is used for managing arabic languages and others (i.e by inverting the direction).</summary>		public DirectionType DrawDirection=DirectionType.LTR;						/// <summary>Creates a new computed style for the given element.</summary>		/// <param name="element">The element that this is a computed style for.</param>		public ComputedStyle(Element element):base(element){}			/// <summary>Checks if this element's box contains the given co-ordinates.</summary>		/// <param name="x">The x coordinate to check.</param>		/// <param name="y">The y coordinate to check.</param>		/// <returns>True if the bounding box of this element contains the coordinate.</returns>		public bool Contains(int x,int y){			return (x>=OffsetLeft && y>=OffsetTop && y<=(OffsetTop+FullHeight) && x<=(OffsetLeft+FullWidth));		}				public bool TransformedOverlap(ComputedStyle style){					if(BGImage==null || style.BGImage==null){				return false;			}						return BGImage.Overlaps(style.BGImage);					}				public void VisibilityNone(){			if(Visibility==VisibilityType.Hidden){				return;			}						Visibility=VisibilityType.Hidden;			Element.WentOffScreen();		}				public void DisplayNone(){			if(Display==DisplayType.None){				return;			}						Display=DisplayType.None;			Element.WentOffScreen();		}				public bool BoxOverlap(ComputedStyle style){						int remoteMax=style.OffsetLeft + style.PixelWidth;						if(OffsetLeft >= remoteMax){				return false;			}						int max=OffsetLeft + PixelWidth;						if(max <= style.OffsetLeft){				return false;			}						remoteMax=style.OffsetTop + style.PixelHeight;						if(OffsetTop >= remoteMax){				return false;			}						max=OffsetTop + PixelHeight;						if(max <= style.OffsetTop){				return false;			}						return true;					}				/// <summary>Gets the position of the midpoint on the x axis.</summary>		public float GetMidpointX(){			return OffsetLeft+(PixelWidth/2f);		}				/// <summary>Gets the position of the midpoint on the y axis.</summary>		public float GetMidpointY(){			return OffsetTop+(PixelHeight/2f);		}				/// <summary>Called when the parent of the element was changed.</summary>		public void ParentChanged(){			// Note that this won't clear any old parent properties.			Element parent=Element.parentNode;			if(parent==null){				return;			}						ComputedStyle newStyle=parent.style.Computed;						// Handle width/height:			SetParentDimension(newStyle.InnerWidth,true,newStyle);			SetParentDimension(newStyle.InnerHeight,false,newStyle);						foreach(KeyValuePair<CssProperty,Css.Value> kvp in newStyle.Properties){				ChangeParentProperty(kvp.Key,kvp.Value);			}					}				/// <summary>The width in pixels of the last whitespace of this element, if it's got one.</summary>		public int EndSpaceSize{			get{								if(Text==null){					return 0;				}								return Text.EndSpaceSize;			}		}				/// <summary>True if this element has some form of background applied to it.</summary>		public bool HasBackground{			get{				return (BGImage!=null || BGColour!=null);			}		}				/// <summary>Checks if this element is offset or positioned.</summary>		/// <returns>True if this element is offset/positioned in any way.</returns>		public bool IsOffset(){			return (PositionLeft!=0||PositionTop!=0||PositionRight!=0||PositionBottom!=0);		}				/// <summary>How much of this elements horizontal content is currently visible? Used by scrolling.</summary>		/// <returns>A value from 0-1 of how much of the horizontal content is visible. 1 is all of it.</returns>		public float VisiblePercentageX(){			return (float)InnerWidth/(float)ContentWidth;		}				/// <summary>How much of this elements vertical content is currently visible? Used by scrolling.</summary>		/// <returns>A value from 0-1 of how much of the vertical content is visible. 1 is all of it.</returns>		public float VisiblePercentageY(){			return (float)InnerHeight/(float)ContentHeight;		}				/// <summary>Called when the mouse is now over this element.		/// Internally, it simply tacks :hover onto all the selectors this tag uses and reloads,		/// but only if the :hover selector exists.</summary>		public bool Hover(){			return SetModifier("hover");		}				/// <summary>Called when the mouse is no longer over this element.		/// This essentially reverses <see cref="PowerUI.ComputedStyle.Hover"/>.</summary>		public void Unhover(){			UnsetModifier("hover");		}				/// <summary>Applies the given CSS modifier (e.g. "hover") to this element. Note: Modifier order matters!</summary>		/// <param name="modifier">The modifier to apply.</param>		/// <returns>True if the modifier was found and applied.</summary>		public bool SetModifier(string modifier){			bool result=false;						if(SetModifier(SelectorType.ID,IDSelector,modifier)){				result=true;			}						if(SetModifier(SelectorType.Tag,TagSelector,modifier)){				result=true;			}						if(SetModifier(SelectorType.Class,ClassSelector,modifier)){				result=true;			}						if(ExtraClassSelectors!=null){								for(int i=ExtraClassSelectors.Length-1;i>=0;i--){										if(SetModifier(SelectorType.Class,ExtraClassSelectors[i],modifier,i)){						result=true;					}									}							}						return result;		}				/// <summary>Called when the mouse is now over this element.</summary>		/// <param name="type">The selector to hover.</param>		/// <param name="selector">The selector's current value. Should not end in :hover.</param>		private bool SetModifier(SelectorType type,string selector,string modifier){			if(selector==null){				return false;			}						if(selector.EndsWith(":"+modifier)){				// Already set.				return true;			}						// Update the selector:			selector=selector+":"+modifier;						// Try additive applying the style now:			if(AddStyle(selector,type)){								// It exists and was set!				switch(type){					case SelectorType.ID:						IDSelector=selector;					break;					case SelectorType.Class:						ClassSelector=selector;					break;					case SelectorType.Tag:						TagSelector=selector;					break;				}								return true;			}						return false;		}				/// <summary>Called when the mouse is now over this element.</summary>		/// <param name="type">The selector to hover.</param>		/// <param name="selector">The selector's current value. Should not end in :hover.</param>		/// <param name="innerIndex">The selector index in ExtraClassSelectors, if any.</param>		private bool SetModifier(SelectorType type,string selector,string modifier,int innerIndex){			if(selector==null){				return false;			}						// Grab previous:			string previous=ExtraClassSelectors[innerIndex];						if(previous.EndsWith(":"+modifier)){				// Already set!				return true;			}						// Update selector:			selector=selector+":"+modifier;						// Try additive setting it:			if(AddStyle(selector,type)){								// It exists and got set - apply it now:				ExtraClassSelectors[innerIndex]=selector;								return true;			}						return false;		}				/// <summary>Unapplies the given CSS modifier (e.g. "hover") to this element.</summary>		/// <param name="modifier">The modifier to apply.</param>		public void UnsetModifier(string modifier){						// Prepend the colon:			modifier=":"+modifier;						UnsetModifier(SelectorType.ID,IDSelector,modifier);			UnsetModifier(SelectorType.Tag,TagSelector,modifier);						if(ExtraClassSelectors!=null){								// Do any contain it?								if(ClassSelector!=null && ClassSelector.Contains(modifier)){										UnsetClassModifier(modifier);									}else if(ExtraClassSelectors!=null){					// Do any of them contain it either?										for(int i=ExtraClassSelectors.Length-1;i>=0;i--){												if(ExtraClassSelectors[i].Contains(modifier)){							// Yep!														UnsetClassModifier(modifier);														return;						}											}									}							}else{				UnsetModifier(SelectorType.Class,ClassSelector,modifier);			}					}				/// <summary>Called to unset a class :modifier when multiple classes are in use.</summary>		/// <param name="modifier">":aModifier" e.g. ":hover".</param>		private void UnsetClassModifier(string modifier){						// First remove all class styles.						if(ClassSelector!=null){								// Remove it:				RemoveStyle(ClassSelector,SelectorType.Class);								// Chop off :hover if it had it:								if( ClassSelector.Contains(modifier) ){										// Chop off the modifier at the end:					ClassSelector=ClassSelector.Substring(0,ClassSelector.LastIndexOf(":"));									}											}						for(int i=0;i<ExtraClassSelectors.Length;i++){								// Grab it:				string selector=ExtraClassSelectors[i];								// Remove it:				RemoveStyle(selector,SelectorType.Class);								// Chop off :hover if it had it:								if( selector.Contains(modifier) ){										// Chop off the modifier at the end:					ExtraClassSelectors[i]=selector.Substring(0,selector.LastIndexOf(":"));									}							}						// Add all of them (in order):						for(int i=0;i<ExtraClassSelectors.Length;i++){								// Add it:				AddStyle(ExtraClassSelectors[i],SelectorType.Class);							}						if(ClassSelector!=null){								// Add it:				AddStyle(ClassSelector,SelectorType.Class);							}					}				/// <summary>Called when the mouse is no longer over this element.</summary>		/// <param name="type">The selector to unhover.</param>		/// <param name="selector">The selector's current value. Should end in ":aModifier".</param>		private void UnsetModifier(SelectorType type,string selector,string modifier){			if( selector==null || !selector.Contains(modifier) ){				return;			}						// Chop off the modifier at the end.			selector=selector.Substring(0,selector.LastIndexOf(":"));						// Must always set the unhover state (as we know for sure we have a :hover tag).			// Even if the tag doesn't exist.			SetSelector(type,selector);		}				/// <summary>Is the named modifier in use on this style?</summary> 		/// <param name="modifier">The modifier, e.g. "hover".</param>		/// <returns>True if the modifier was detected.</returns>		public bool HasModifier(string modifier){						// Prepend the colon:			modifier=":"+modifier;						if(TagSelector!=null && TagSelector.Contains(modifier)){				return true;			}						if(ClassSelector!=null && ClassSelector.Contains(modifier)){				return true;			}						if(ExtraClassSelectors!=null){				// Do any of them contain it either?								for(int i=ExtraClassSelectors.Length-1;i>=0;i--){										if(ExtraClassSelectors[i].Contains(modifier)){						// Yep!						return true;					}									}							}						if(IDSelector!=null && IDSelector.Contains(modifier)){				return true;			}						return false;		}				/// <summary>Makes this element refetch the style of the given selector.		/// E.g. This is called if an element is loaded before the style tag is.		/// The body element is currently the only one this occurs with. When the style loads,		/// it tells the body tag to refresh itself with this method.</summary>		/// <param name="type">The type of selector to refetch.</param>		public void RefreshSelector(SelectorType type){			string selector=null;						if(type==SelectorType.Tag){				selector=TagSelector;			}else if(type==SelectorType.Class){				selector=ClassSelector;			}else if(type==SelectorType.ID){				selector=IDSelector;			}						if(selector==null){				// Nothing to refresh anyway (won't have extras either).				return;			}						if(type==SelectorType.Class){								if(ExtraClassSelectors!=null){										// Add forwards.										for(int i=0;i<ExtraClassSelectors.Length;i++){												// Add it:						AddStyle(ExtraClassSelectors[i],type);											}									}								// Important to add the "selector" last.							}						// Add them in:			AddStyle(selector,type);					}				/// <summary>Removes the given style from this computed style.</summary>		/// <param name="selector">The style to remove.</param>		/// <param name="type">The type of style that it is.</param>		public bool RemoveStyle(string selector,SelectorType type){						// Grab the style:			Css.SelectorStyle style=Element.Document.getStyleBySelector(selector);						if(style==null){				return false;			}						switch(type){				case SelectorType.ID:										foreach(KeyValuePair<CssProperty,Css.Value> kvp in style.Properties){						ChangeIDProperty(kvp.Key,null);					}									break;				case SelectorType.Tag:										foreach(KeyValuePair<CssProperty,Css.Value> kvp in style.Properties){						ChangeTagProperty(kvp.Key,null);					}									break;				default:										foreach(KeyValuePair<CssProperty,Css.Value> kvp in style.Properties){						ChangeClassProperty(kvp.Key,null);					}									break;			}						return true;					}				/// <summary>Adds the given style from this computed style as a style of the given type.</summary>		/// <param name="selector">The style to add.</param>		/// <param name="type">The type of style that it is.</param>		public bool AddStyle(string selector,SelectorType type){						// Lookup the selector:			Css.SelectorStyle style=Element.Document.getStyleBySelector(selector);						if(style==null){				return false;			}						switch(type){				case SelectorType.ID:										foreach(KeyValuePair<CssProperty,Css.Value> kvp in style.Properties){						ChangeIDProperty(kvp.Key,kvp.Value);					}									break;				case SelectorType.Tag:										foreach(KeyValuePair<CssProperty,Css.Value> kvp in style.Properties){						ChangeTagProperty(kvp.Key,kvp.Value);					}									break;				default:										foreach(KeyValuePair<CssProperty,Css.Value> kvp in style.Properties){						ChangeClassProperty(kvp.Key,kvp.Value);					}									break;			}						return true;					}				/// <summary>Sets a css selector that will apply to this element (e.g. it's class or id).</summary>		/// <param name="type">The type of the selector being applied.</param>		/// <param name="value">The selector value/ name to use. Note this is just the name; no # etc.</param>		public void SetSelector(SelectorType type,string value){			if(value==""){				value=null;			}						// This value is true if there are multiple classes in the new value:			bool multiClasses=false;						// This is true if the previous value had multiple classes:			bool prevMultiClasses=false;						string previousSelector=null;						if(type==SelectorType.ID){				if(value==IDSelector){					return;				}else{					// It's changing.					previousSelector=IDSelector;					IDSelector=value;				}			}else if(type==SelectorType.Tag){				if(value==TagSelector){					return;				}else{					// It's changing.					previousSelector=TagSelector;					TagSelector=value;				}			}else{				// Class selector type.				if(value==ClassSelector){					// Unchanged.					return;				}else{					// It's changing.					previousSelector=ClassSelector;					ClassSelector=value;										// Has it got more than one?					multiClasses=(value!=null && value.Contains(" "));										// Did it have more than one?					prevMultiClasses=(ExtraClassSelectors!=null);				}			}									// It changed.			if(previousSelector!=null){				// Possible future performance update: If value isn't null, only remove the difference				// between style and value.								if(prevMultiClasses){										// Remove each one. Note that the first will contain a dot and we need to add that to each one after.					for(int i=0;i<ExtraClassSelectors.Length;i++){												// Grab it (starts with a dot):						string classSelector=ExtraClassSelectors[i];												// Remove it entirely:						RemoveStyle(classSelector,type);											}										// Clear the set:					ExtraClassSelectors=null;									}								// Remove it entirely:				RemoveStyle(previousSelector,type);							}						if(multiClasses){				// Split:				string[] classes=value.Split(' ');								// Grab the very last one ("main"). Note that it will never start with a dot. Set it to the class selector:				ClassSelector="."+classes[classes.Length-1];								// Create the new set, minus the "main" one which is the last in the classes set:				ExtraClassSelectors=new string[classes.Length-1];								// Add each one. Note that the first will contain a dot and we need to add that to each one after.				for(int i=0;i<ExtraClassSelectors.Length;i++){										// Grab it:					string className=classes[i];										if(className==""){						continue;					}										// Prepend a dot to all but the first.					if(i!=0){						// Prepend the dot:						className="."+className;					}										// Put it in the set:					ExtraClassSelectors[i]=className;										// Add it in:					AddStyle(className,type);				}								// Add the last one:				AddStyle(ClassSelector,type);							}else{							// Single one - add it:				AddStyle(value,type);							}					}				/// <summary>Called when a parent object changes its properties. This applies the value only if		/// this element wants to 'inherit' the property.</summary>		/// <param name="property">The css property being changed.</param>		/// <param name="newValue">The new property value.</param>		public void ChangeParentProperty(CssProperty property,Css.Value newValue){						if(Element.Handler.IsIsolated){				// It also only applies when the element accepts any parent changes at all.				// In this case, it doesnt. (e.g. an iframe):				if(property.IsWidthOrHeight){					return;				}							}						// So, simply look for the property and if it's value is inherit or not.			Css.Value currentProperty=this[property];						if(currentProperty==null){				return;			}						if(currentProperty.Type==ValueType.Inherit){				// Yay!!				currentProperty.InheritFrom(newValue);								// Change property will next make sure that the value is actually applied				// And also results in this call recursing to any further kids.				ChangeProperty(property,currentProperty);			}		}				/// <summary>Gets the CSS property value defined by the style="" attribute for the given property. Fully resolved properties only.</summary>		/// <param name="property">The CSS property to get the value for.</param>		public Css.Value GetLocalStyle(string property){						// Get the property:			CssProperty cssProperty=CssProperties.Get(property);						if(cssProperty==null){				// Doesn't exist - can't have been set.				return null;			}						// Return it:			return Element.style[cssProperty];		}				/// <summary>Gets the CSS property value defined by the style="" attribute for the given property.</summary>		/// <param name="property">The CSS property to get the value for.</param>		public Css.Value GetLocalStyle(CssProperty property){			return Element.style[property];		}				/// <summary>This is called to change the named property on this element.</summary>		/// <param name="property">The css property being changed.</param>		/// <param name="newValue">The new property value.</param>		public void ChangeProperty(CssProperty property,Css.Value newValue){					Css.Value current=this[property];						if(newValue==null && current==null){				return;			}						if(newValue!=current){				// Make sure their not the same object.				// If they are the same object, we just simply want the value to be changed for rendering only.				if(newValue!=null){					// This computes percentage values, including ones contained in rectangles. 					// It also looks for property:inherit.										if(!newValue.IsAbsolute()){						// We can't just use the same object unfortunately; grab a copy of it.						newValue=newValue.Copy();												// Try and resolve it now:						newValue.MakeAbsolute(property,Element);					}				}								if(newValue!=null && current!=null && newValue.Equals(current)){					return;				}								// Their different - we have a new value.				this[property]=newValue;			}						// Apply it:			property.Apply(this,newValue);						// Tell all decendents that this object changed a property:			// This is important for inherited properties, like font size/colour.			List<Element> kids=Element.childNodes;						if(kids!=null){							// Foreach child, request that it is recomputed too:				for(int i=0;i<kids.Count;i++){					// Flag it that a parent changed a property:					kids[i].Style.Computed.ChangeParentProperty(property,newValue);				}			}					}				/// <summary>Inline elements with border/bg colour/bg image should split the properties across multiple lines.		/// This looks pretty ugly and is complex enough that it is instead replaced with enforcing inline-block in this situation.		/// This method enforces inline-block if it's required.</summary>		public void EnforceNoInline(){			if(Border==null && BGColour==null && BGImage==null){				return;			}						if(Display==DisplayType.Inline){				Display=DisplayType.InlineBlock;			}		}				/// <summary>Sets up the <see cref="PowerUI.ComputedStyle.Transform"/> object if one is needed.</summary>		/// <param name="newValue">If this value is null, no transform will be created as it's not needed.</param>		/// <returns>True if transform is set.</returns>		public bool SetupTransform(Css.Value newValue){			if(Transform==null){				if(newValue==null){					return false;				}				Transform=new Transformation();			}			return true;		}				/// <summary>Checks if the given overflow type requires a scrollbar.</summary>		/// <param name="type">The overflow type to check.</param>		/// <returns>True if it's auto or scroll; false otherwise.</returns>		private bool NeedsScrollbar(OverflowType type){			return (type==OverflowType.Auto || type==OverflowType.Scroll);		}				/// <summary>Generates a new scrollbar with the given orientation.</summary>		/// <param name="horizontal">True for a horizontal scrollbar, false for vertical.</param>		private InputTag MakeScrollbar(bool horizontal){			string scrollDir=horizontal?"h":"v";			Element newElement=new Element("<input type='"+scrollDir+"scroll'>",Element);			return (InputTag)(newElement.Handler);		}				/// <summary>Resets the scrollbar elements for this element.</summary>		public void ResetScrollbars(){			bool hasHBar=(Element.HScrollbar);			bool hasVBar=(Element.VScrollbar);						bool needsHBar=NeedsScrollbar(OverflowX);			bool needsVBar=NeedsScrollbar(OverflowY);						if(hasHBar==needsHBar && hasVBar==needsVBar){				return;			}						if(hasHBar!=needsHBar){								if(needsHBar){										//Generate a new scrollbar:					Element.HorizontalScrollbar=MakeScrollbar(true);					Element.HScrollbar=true;									}else{										Element.HorizontalScrollbar.Element.WentOffScreen();					Element.HScrollbar=false;					Element.HorizontalScrollbar=null;									}							}						if(hasVBar!=needsVBar){								if(needsVBar){										// Generate a new scrollbar:					Element.VerticalScrollbar=MakeScrollbar(false);					Element.VScrollbar=true;								}else{										Element.VerticalScrollbar.Element.WentOffScreen();					Element.VScrollbar=false;					Element.VerticalScrollbar=null;									}							}						RequestLayout();		}				/// <summary>Recalculates the pixel width, padded width and full width of this element.</summary>		/// <param name="tellHandler">True if the Handler should be told the width changed.</param>		public void SetPixelWidth(bool tellHandler){			if(Display==DisplayType.Block && !FixedWidth){				Element parent=Element.parentNode;				if(parent==null){					InnerWidth=0;				}else{					InnerWidth=parent.Style.Computed.InnerWidth;				}				InnerWidth+=-PaddingLeft-PaddingRight;				if(Border!=null){					InnerWidth-=Border.WidthLeft+Border.WidthRight;				}			}						if(InnerWidth>MaximumWidth){				InnerWidth=MaximumWidth;			}						if(InnerWidth<MinimumWidth){				InnerWidth=MinimumWidth;			}						PaddedWidth=InnerWidth+PaddingRight;						PixelWidth=PaddedWidth+StyleOffsetLeft+MarginRight+MarginLeft;			PaddedWidth+=PaddingLeft;						if(Border!=null){				// Border left included in StyleOffsetLeft already, so just right:				PixelWidth+=Border.WidthRight;			}						FullWidth=PaddedWidth;			if(Border!=null){				FullWidth+=Border.WidthLeft+Border.WidthRight;			}						if(tellHandler){				Element.Handler.WidthChanged();			}					}				/// <summary>Recalculates the pixel height, padded height and full height of this element.</summary>		/// <param name="tellHandler">True if the Handler should be told the height changed.</param>		public void SetPixelHeight(bool tellHandler){						if(InnerHeight>MaximumHeight){				InnerHeight=MaximumHeight;			}						PaddedHeight=InnerHeight+PaddingBottom;			PixelHeight=PaddedHeight+StyleOffsetTop+MarginBottom+MarginTop;			PaddedHeight+=PaddingTop;						if(Border!=null){				// Border top included in StyleOffsetTop already, so just bottom:				PixelHeight+=Border.WidthBottom;			}						FullHeight=PaddedHeight;			if(Border!=null){					FullHeight+=Border.WidthTop+Border.WidthBottom;			}						if(tellHandler){				Element.Handler.HeightChanged();			}		}				/// <summary>Recalculates the pixel width/height and style offsets.</summary>		public void SetSize(){						if(Border!=null){				BorderTop=Border.WidthTop;				BorderLeft=Border.WidthLeft;			}else{				BorderTop=BorderLeft=0;			}						StyleOffsetTop=PaddingTop+BorderTop;			StyleOffsetLeft=PaddingLeft+BorderLeft;						SetPixelWidth(true);			SetPixelHeight(true);						StyleOffsetTop-=ScrollTop;			StyleOffsetLeft-=ScrollLeft;		}				/// <summary>Requests that this element and all it's kids are retransformed.		/// Transforming is a post process, so this is like calling for a paint.</summary>		public void RequestTransform(){			// Needs to essentially request a paint, but with a transform flag high (Transform.Changed).			// When paint hits this element, it checks if we're affecting transform.			// If we are, it must re-transform *all kids*.			Element.Document.Renderer.RequestPaint(Element.Style);		}				/// <summary>Requests that the renderer performs a layout on the next update.		/// Note that layouts are more expensive than a paint. Paints simply update vertex colours		/// and uvs where as layouts rebuild the whole mesh.</summary>		public void RequestLayout(){			Element.Document.Renderer.RequestLayout();		}				/// <summary>Called when either height or width of the parent element changes.		/// This is used to convert % into actual pixels and may recurse to it's children.</summary>		/// <param name="dimension">The new value of the width/height in pixels.</param>		/// <param name="isWidth">True if width is what changed and the dimension is width.</param>		/// <param name="parent">The parents computed style that has changed.</param>		public void SetParentDimension(int dimension,bool isWidth,ComputedStyle parent){			// If a change occurs, call ChangeProperty and just give it the existing value.			// This enables recursion if we're setting a relative width or height			// as the call to this originates from ChangeProperty with width/height.						// Firstly, remove our padding from the dimension.			if(isWidth){				dimension-=PaddingLeft+PaddingRight;			}else{				dimension-=PaddingTop+PaddingBottom;			}						foreach(KeyValuePair<CssProperty,Css.Value> kvp in Properties){								Css.Value value=kvp.Value;								if(value==null){					continue;				}								if(value.Type==ValueType.Inherit){					// Ignore it (this is important because inherit is considered in IsAbsolute() )					continue;				}								if(value.IsAbsolute()){					// Doesn't contain any percentages anywhere - it won't be affected.					continue;				}								// Grab the property:				CssProperty property=kvp.Key;								if(value.Type==ValueType.Percentage){									if(property.IsXProperty){												if(!isWidth){							// We're only interested in properties along y.							continue;						}											}else if(isWidth){						// We're only interested in properties along x.						continue;					}										// Got one! bake it.					value.BakePX(dimension);					ChangeProperty(property,value);									}else if(value.InnerValues!=null){					// Rectangle of some sort; Bake only the parts for this 										int count=value.InnerValues.Length;										int start;										if(count==4){												start=isWidth?1:0;											}else{												start=isWidth?0:1;											}										for(int i=start;i<count;i+=2){												Value innerValue=value.InnerValues[i];												if(innerValue.Type==ValueType.Percentage){							innerValue.BakePX(dimension);						}											}										ChangeProperty(property,value);									}							}						if(isWidth){				if(!FixedWidth){					// Time to deal with an exception - block elements have a width of 100% by default.					// So, if we didn't define one, apply 100% here.					if(Display==DisplayType.Block){						// Apply 100% here:						SetPixelWidth(true);						// And bubble upwards:						Element.SetWidthForKids(this);					}else{						// Continue bubbling upwards:						Element.SetWidthForKids(parent);					}				}			}else if(!FixedHeight){				// Continue bubbling upwards:				Element.SetHeightForKids(parent);			}		}				/// <summary>Repaints this element at OffsetLeft/OffsetTop with the given PixelWidth and PixelHeight values.		/// A paint is less intensive than a layout as it only updates the uv/vert colours of the mesh.</summary>		public void Repaint(){			if(Display==DisplayType.None || Visibility==VisibilityType.Hidden){				WentOffScreen();				return;			}						if(BGColour!=null){				BGColour.Paint();			}						if(Border!=null){				Border.Paint();			}						if(BGImage!=null){				BGImage.Paint();			}						if(Text!=null){				Text.Paint();			}						if(Transform!=null && Transform.Changed){				// The transform changed.				// To deal with this, we need to:				//  - Recalc the transform matrix and the matrix of all it's derivatives.				//  - Call ApplyTransform() on each ComputedStyle of elements (this, including kids) that were affected.				ApplyTransform();			}		}				/// <summary>Applies the transform (rotate, scale etc) of this element to its background/border/content.</summary>		protected void ApplyTransform(){			if(Transform!=null){				// Recalculate it's matrix.				// This must always be done as it may be deriving from something which has now changed, or it may have changed itself.				// It will always be one of the above as this function is being called.				Transform.RecalculateMatrix(this);			}						if(BGColour!=null){				BGColour.ApplyTransform();			}						if(Border!=null){				// Special case here as borders may have round corners and an inner renderer.				Border.ApplyBorderTransform();			}						if(BGImage!=null){				BGImage.ApplyTransform();			}						if(Text!=null){				Text.ApplyTransform();			}						// Apply transform for all kids.			List<Element> childNodes=Element.childNodes;			if(childNodes!=null){				for(int i=0;i<childNodes.Count;i++){					childNodes[i].Style.Computed.ApplyTransform();				}			}		}				public void WentOffScreen(){						if(Border!=null){				Border.WentOffScreen();			}						if(BGColour!=null){				BGColour.WentOffScreen();			}						if(BGImage!=null){				BGImage.WentOffScreen();			}						if(Text!=null){				Text.WentOffScreen();			}					}				/// <summary>Draws this at OffsetLeft/OffsetTop with the given PixelWidth and PixelHeight values.</summary>		public void Render(){			if(Display==DisplayType.None || Visibility==VisibilityType.Hidden){				WentOffScreen();				return;			}						Element.Handler.OnLayout();						// Get the transform at the top of the stack:			Transformation topTransform=Element.Document.Renderer.Transformations.Last;						if(Border!=null){				Border.Render();								if(Border.Corners==null){					Border.Transform(topTransform);				}			}						if(BGColour!=null){				BGColour.Render();				BGColour.Transform(topTransform);			}						if(BGImage!=null){								BGImage.Render();				BGImage.Transform(topTransform);			}						if(Text!=null){				Text.Render();				Text.Transform(topTransform);			}						if(Border!=null && Border.Corners!=null){				// Render the corners now:				Border.RenderCorners();								// Transform the whole border:				Border.BorderTransform(topTransform);							}					}			}	}