//--------------------------------------//          Blaze Rasteriser////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;namespace Blaze{	public partial class VectorPoint{				/// <summary>The X coordinate of this path node.</summary>		public float X;		/// <summary>The Y coordinate of this path node.</summary>		public float Y;		/// <summary>The x axis of the normal at this point.</summary>		public float NormalX;		/// <summary>The y axis of the normal at this point.</summary>		public float NormalY;		/// <summary>Path nodes are stored as a linked list. The one after this node.</summary>		public VectorPoint Next;		/// <summary>Path nodes are stored as a linked list. The one before this node.</summary>		public VectorPoint Previous;						/// <summary>Creates an empty path node.</summary>		public VectorPoint(){}				/// <summary>Creates a node at the given point.</summary>		/// <param name="x">The X coordinate of this path node.</param>		/// <param name="y">The Y coordinate of this path node.</param>		public VectorPoint(float x,float y){			X=x;			Y=y;		}				public virtual void MultiplyNormals(float by){						NormalX*=by;			NormalY*=by;					}				/// <summary>True if this path is unloaded. Used to improve font load time of large fonts.</summary>		public virtual bool Unloaded{			get{				return false;			}		}				/// <summary>Recalculates the minimum values and width/height of this path, taking curves into account.</summary>		public virtual void RecalculateBounds(VectorPath path){						if(X<path.MinX){				path.MinX=X;			}						if(Y<path.MinY){				path.MinY=Y;			}						// Width/height are used as max to save some memory:			if(X>path.Width){				path.Width=X;			}						if(Y>path.Height){				path.Height=Y;			}					}				/// <summary>Splits this vector line into two at the given parametric point.</summary>		public virtual VectorPoint Split(float t,VectorPath path){						return null;					}				/// <summary>Steps along the line between this point and previous point at a fixed step, adding the points to the scanner as it goes.</summary>		public virtual void ComputeLinePoints(PointReceiver output){					}				/// <summary>Is this a curve line?</summary>		public virtual bool IsCurve{			get{				return false;			}		}				/// <summary>Is there a line from this point to the previous one?</summary>		public virtual bool HasLine{			get{				return false;			}		}				/// <summary>Gets the normal at the start of the line from this to previous.</summary>		public virtual void StartNormal(out float x,out float y){			x=0f;			y=0f;		}				/// <summary>Gets the normal at the end of the line from this to previous.</summary>		public virtual void EndNormal(out float x,out float y){			x=0f;			y=0f;		}				/// <summary>Computes the control point normals for any curves.</summary>		public virtual void RecalculateCurveNormals(){				}				/// <summary>Extrudes this point along its normal by the given distance.</summary>		public virtual void Extrude(float by){						X+=NormalX*by;			Y+=NormalY*by;					}				public virtual VectorPoint Copy(){						return null;					}				public VectorPoint GetShapeEnd(){						if(Next==null){				return this;			}						VectorPoint current=Next;						while(current!=null){								// Nothing after it or the next one is a moveto:				if(current.Next==null || !current.Next.HasLine){					return current;				}								current=current.Next;							}						// This is actually unreachable:			return null;		}				public virtual void Transform(VectorTransform transform){						float x=X;			X=(transform.XScale * x + transform.Scale01 * Y + transform.Dx);			Y=(transform.Scale10 * x + transform.YScale * Y + transform.Dy);					}				public virtual bool IsClose{			get{				return false;			}			set{}		}				public override string ToString(){			return "";		}				public virtual void Multiply(float by){			X*=by;			Y*=by;		}				public virtual void Squash(float by){			Y*=by;		}				public virtual void Sheer(float by){						X+=Y*by;					}			}}