//--------------------------------------//          Blaze Rasteriser////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;using System.Collections;using System.Collections.Generic;namespace Blaze{	public partial class VectorPath{				/// <summary>The minimum X value.</summary>		public float MinX;		/// <summary>The minimum Y value.</summary>		public float MinY;		/// <summary>The width of this path.</summary>		public float Width;		/// <summary>The height of this path.</summary>		public float Height=1f;		/// <summary>The number of points in this vector path.</summary>		public int PathNodeCount;		/// <summary>The current node which will be used when the path is closed.</summary>		public MoveToPoint CloseNode;		/// <summary>When creating a path its nodes are stored as a linked list. The first node created.</summary>		public VectorPoint FirstPathNode;		/// <summary>When creating a path its nodes are stored as a linked list. The latest node created.</summary>		public VectorPoint LatestPathNode;				/// <summary>Moves the current pen location to the given point. Used when drawing paths.</summary>		public void MoveTo(float x,float y){						// We need to add the first end:			MoveToPoint point=new MoveToPoint(x,y);						AddPathNode(point);						CloseNode=point;					}				/// <summary>Copies this vector path into the given one.</summary>		public void CopyInto(VectorPath path){						VectorPoint point=FirstPathNode;						while(point!=null){								VectorPoint copiedPoint=point.Copy();								path.AddPathNode(copiedPoint);								// Copy close status:				if(point.IsClose){										copiedPoint.IsClose=true;					path.CloseNode.ClosePoint=copiedPoint;									}								point=point.Next;			}								}				/// <summary>Clears this path.</summary>		public void Clear(){			FirstPathNode=null;			LatestPathNode=null;			PathNodeCount=0;		}				/// <summary>Adds the given node to this path.</summary>		public void AddPathNode(VectorPoint point){						PathNodeCount++;						if(FirstPathNode==null){								if(point.Unloaded){										FirstPathNode=LatestPathNode=point;									}else{									MoveToPoint move=point as MoveToPoint;									if(move==null){												// Add a blank MoveTo - this means that moveTo's are always the close nodes.						move=new MoveToPoint(0f,0f);						FirstPathNode=LatestPathNode=move;						CloseNode=move;												PathNodeCount++;												point.Previous=move;						LatestPathNode=move.Next=point;											}else{												FirstPathNode=LatestPathNode=point;						CloseNode=move;											}								}							}else{								// Hook it onto the end:				point.Previous=LatestPathNode;				LatestPathNode=LatestPathNode.Next=point;			}					}				/// <summary>Closes the path quickly and safely.</summary>		public void ClosePathFast(){					if(CloseNode==null || LatestPathNode==null){				return;			}						StraightLinePoint point=LineTo(CloseNode.X,CloseNode.Y);			point.Close=true;			CloseNode.ClosePoint=point;					}				/// <summary>A full path close.</summary>		public void ClosePath(){						if(CloseNode==null || LatestPathNode==null){				return;			}						if(LatestPathNode.X==CloseNode.X && LatestPathNode.Y==CloseNode.Y){				LatestPathNode.IsClose=true;				CloseNode.ClosePoint=LatestPathNode;			}else{				StraightLinePoint point=LineTo(CloseNode.X,CloseNode.Y);				point.Close=true;				CloseNode.ClosePoint=point;			}					}				/// <summary>Marks the last node as a close.</summary>		public void CloseLast(){						if(LatestPathNode==null){				return;			}						LatestPathNode.IsClose=true;						if(CloseNode!=null){				CloseNode.ClosePoint=LatestPathNode;			}					}				public StraightLinePoint LineTo(float x,float y){						// Create the straight line:			StraightLinePoint newNode=new StraightLinePoint(x,y);						// Add it:			AddPathNode(newNode);						return newNode;					}				public QuadLinePoint QuadraticCurveTo(float cx,float cy,float x,float y){						// Create the curve line:			QuadLinePoint newNode=new QuadLinePoint(x,y);						newNode.Control1X=cx;			newNode.Control1Y=cy;						// Add it:			AddPathNode(newNode);						return newNode;		}				public void CurveTo(float c1x,float c1y,float c2x,float c2y,float x,float y){						// Create the curve line:			CurveLinePoint newNode=new CurveLinePoint(x,y);						newNode.Control1X=c1x;			newNode.Control1Y=c1y;			newNode.Control2X=c2x;			newNode.Control2Y=c2y;						// Add it:			AddPathNode(newNode);					}				/// <summary>Recalculates bounds and normals.</summary>		public void RecalculateMeta(){			RecalculateBounds();			RecalculateNormals();		}				/// <summary>Recalculates the minimum values and width/height of this path, taking curves into account.</summary>		public void RecalculateBounds(){						if(FirstPathNode==null){								Width=0f;				Height=0f;				MinY=0f;				MinX=0f;								return;							}						// Our temp boundaries:			MinX=float.MaxValue;			MinY=float.MaxValue;						// We'll be using width/height temporarily as max:			Width=float.MinValue;			Height=float.MinValue;						VectorPoint current=FirstPathNode;						while(current!=null){								// Recalc bounds:				current.RecalculateBounds(this);								// Hop to the next one:				current=current.Next;			}						// Remove min values from width/height:			Width-=MinX;			Height-=MinY;					}				/// <summary>Recalculates the normals of this path. Not required unless you're using SDF.</summary>		public virtual void RecalculateNormals(){						if(FirstPathNode==null){				return;			}						VectorPoint current=FirstPathNode;						while(current!=null){								// Recalc curve normals:				current.RecalculateCurveNormals();								// Hop to the next one:				current=current.Next;			}						VectorPoint moveTo=null;						current=FirstPathNode;						while(current!=null){								// Recalc curve normals:								//4. For each point, query the lines on either side for their start/end normals and avg them.								float afterNX;				float afterNY;								float beforeNX;				float beforeNY;				bool updateMoveTo=false;								if(!current.HasLine){										// Current is a MoveTo:					moveTo=current;										// Hop to the next one:					current=current.Next;										continue;									}else if(current.IsClose || current.Next==null){										// This point is followed by a MoveTo.										if(moveTo==null){												// Hop to the next one:						current=current.Next;												continue;											}										// Pair with moveTo:					current.EndNormal(out beforeNX,out beforeNY);					moveTo.Next.StartNormal(out afterNX,out afterNY);					updateMoveTo=true;									}else{										// Line from current->previous and line from current->Next.					current.EndNormal(out beforeNX,out beforeNY);					current.Next.StartNormal(out afterNX,out afterNY);									}								float nX=(afterNX + beforeNX) / 2f;				float nY=(afterNY + beforeNY) / 2f;								// Normalise:				float length=(float)Math.Sqrt((nX * nX) + (nY * nY));				current.NormalX=nX/length;				current.NormalY=nY/length;								if(updateMoveTo){										moveTo.NormalX=current.NormalX;					moveTo.NormalY=current.NormalY;										// Use it up:					moveTo=null;									}								// Hop to the next one:				current=current.Next;			}					}				/// <summary>Extrudes this path along it's normals. Used to e.g. make something bold. Assumes one or more closed loops and that RecalculateNormals has been called.</summary>		public void Extrude(float by){						VectorPoint current=FirstPathNode;						while(current!=null){								// Pull it out:				current.Extrude(by);								// Hop to the next one:				current=current.Next;			}					}				/// <summary>Sheers this path. Note that it's assumed to be at most 1 unit tall.</summary>		public void Sheer(float by){						VectorPoint current=FirstPathNode;						while(current!=null){								current.Sheer(by);								// Hop to the next one:				current=current.Next;			}					}				/// <summary>Multiply the normals of this path by the given value.</summary>		public void MultiplyNormals(float by){						VectorPoint current=FirstPathNode;						while(current!=null){								current.MultiplyNormals(by);								// Hop to the next one:				current=current.Next;			}					}				/// <summary>Scales this path by the given value.</summary>		public void Scale(float by){						VectorPoint current=FirstPathNode;						while(current!=null){								current.Multiply(by);								// Hop to the next one:				current=current.Next;			}						// Scale the dimensions:			MinX*=by;			MinY*=by;			Width*=by;			Height*=by;					}				/// <summary>Gets the signed area of the "major" contour (the first one).		/// It's signed as this can identify the winding order.</summary>		public float GetSignedArea(){			float sum=0f;						VectorPoint current=FirstPathNode;						while(current!=null){								VectorPoint next=current.Next;								if(next==null){					// We're done!					break;				}								if(next.HasLine){					sum+=(next.Y+current.Y) * (next.X-current.X);				}								current=next;			}						return sum/2f;		}				/// <summary>True if this glyph is currently unclosed.</summary>		public bool Unclosed{			get{								if(CloseNode==null){					return true;				}								if(LatestPathNode.X==CloseNode.X && LatestPathNode.Y==CloseNode.Y){					return false;				}								return true;							}		}				public override string ToString(){						string text="";						VectorPoint current=FirstPathNode;						while(current!=null){								text+=current.ToString()+"\r\n";								// Hop to the next one:				current=current.Next;			}						return text;					}			}}